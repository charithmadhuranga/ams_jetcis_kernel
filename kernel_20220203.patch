diff -ruN kernel_orig/kernel-4.9/arch/arm64/configs/tegra_defconfig kernel_ams/kernel-4.9/arch/arm64/configs/tegra_defconfig
--- kernel_orig/kernel-4.9/arch/arm64/configs/tegra_defconfig	2021-07-26 21:08:43.000000000 +0200
+++ kernel_ams/kernel-4.9/arch/arm64/configs/tegra_defconfig	2022-02-03 12:41:00.779439870 +0100
@@ -778,6 +778,7 @@
 CONFIG_VIDEO_TEGRA_VIVID=m
 # CONFIG_MEDIA_SUBDRV_AUTOSELECT is not set
 CONFIG_VIDEO_IMX185=m
+CONFIG_VIDEO_CSG1K=y
 CONFIG_VIDEO_IMX219=y
 CONFIG_VIDEO_IMX477=y
 CONFIG_VIDEO_IMX268=y
diff -ruN kernel_orig/kernel-4.9/scripts/Kbuild.include kernel_ams/kernel-4.9/scripts/Kbuild.include
--- kernel_orig/kernel-4.9/scripts/Kbuild.include	2021-07-26 21:08:47.000000000 +0200
+++ kernel_ams/kernel-4.9/scripts/Kbuild.include	2022-02-03 13:40:52.204821810 +0100
@@ -461,8 +461,10 @@
 # It's a common trick to declare makefile variable that contains space
 # we'll need it to convert the path string to list (string delimited by spaces)
 # and vice versa
-the-space :=
-the-space += 
+#the-space :=
+#the-space += 
+E =
+the-space = $E $E
 # TEGRA_ROOT_PATH is the relative path to the directory one level upper than $srctree
 _TEGRA_ROOT_PATH = $(subst ^$(realpath $(srctree)/..)/,,^$(realpath $(kbuild-dir)))
 # _TEGRA_REL_PATH is path like "../../../" that points to directory one level
diff -ruN kernel_orig/kernel-4.9/signing_key.x509 kernel_ams/kernel-4.9/signing_key.x509
--- kernel_orig/kernel-4.9/signing_key.x509	2021-07-26 21:09:34.000000000 +0200
+++ kernel_ams/kernel-4.9/signing_key.x509	1970-01-01 01:00:00.000000000 +0100
@@ -1,24 +0,0 @@
------BEGIN CERTIFICATE-----
-MIID/TCCAuWgAwIBAgIJAJcPmDkJqolJMA0GCSqGSIb3DQEBBQUAMIGUMQswCQYD
-VQQGEwJVUzETMBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4g
-VmlldzEQMA4GA1UECgwHQW5kcm9pZDEQMA4GA1UECwwHQW5kcm9pZDEQMA4GA1UE
-AwwHQW5kcm9pZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTAe
-Fw0xNDExMDYxOTA3NDBaFw00MjAzMjQxOTA3NDBaMIGUMQswCQYDVQQGEwJVUzET
-MBEGA1UECAwKQ2FsaWZvcm5pYTEWMBQGA1UEBwwNTW91bnRhaW4gVmlldzEQMA4G
-A1UECgwHQW5kcm9pZDEQMA4GA1UECwwHQW5kcm9pZDEQMA4GA1UEAwwHQW5kcm9p
-ZDEiMCAGCSqGSIb3DQEJARYTYW5kcm9pZEBhbmRyb2lkLmNvbTCCASIwDQYJKoZI
-hvcNAQEBBQADggEPADCCAQoCggEBAOjreE0vTVSRenuzO9vnaWfk0eQzYab0gqpi
-6xAzi6dmD+ugoEKJmbPiuE5Dwf21isZ9uhUUu0dQM46dK4ocKxMRrcnmGxydFn6o
-fs3ODJMXOkv2gKXL/FdbEPdDbxzdu8z3yk+W67udM/fW7WbaQ3DO0knu+izKak/3
-T41c5uoXmQ81UNtAzRGzGchNVXMmWuTGOkg6U+0I2Td7K8yvUMWhAWPPpKLtVH9r
-AL5TzjYNR92izdKcz3AjRsI3CTjtpiVABGeX0TcjRSuZB7K9EK56HV+OFNS6I1NP
-jdD7FIShyGlqqZdUOkAUZYanbpgeT5N7QL6uuqcGpoTOkalu6kkCAwEAAaNQME4w
-HQYDVR0OBBYEFH5DM/m7oArf4O3peeKO0ZIEkrQPMB8GA1UdIwQYMBaAFH5DM/m7
-oArf4O3peeKO0ZIEkrQPMAwGA1UdEwQFMAMBAf8wDQYJKoZIhvcNAQEFBQADggEB
-AHO3NSvDE5jFvMehGGtS8BnFYdFKRIglDMc4niWSzhzOVYRH4WajxdtBWc5fx0ix
-NF/+hVKVhP6AIOQa+++sk+HIi7RvioPPbhjcsVlZe7cUEGrLSSveGouQyc+j0+m6
-JF84kszIl5GGNMTnx0XRPO+g8t6h5LWfnVydgZfpGRRg+WHewk1U2HlvTjIceb0N
-dcoJ8WKJAFWdcuE7VIm4w+vF/DYX/A2Oyzr2+QRhmYSv1cusgAeC1tvH4ap+J1Lg
-UnOu5Kh/FqPLLSwNVQp4Bu7b9QFfqK8Moj84bj88NqRGZgDyqzuTrFxn6FW7dmyA
-yttuAJAEAymk1mipd9+zp38=
------END CERTIFICATE-----
diff -ruN kernel_orig/nvidia/drivers/media/i2c/csg1k.c kernel_ams/nvidia/drivers/media/i2c/csg1k.c
--- kernel_orig/nvidia/drivers/media/i2c/csg1k.c	1970-01-01 01:00:00.000000000 +0100
+++ kernel_ams/nvidia/drivers/media/i2c/csg1k.c	2022-02-03 12:40:17.013840701 +0100
@@ -0,0 +1,1603 @@
+/*
+ * csg1k_v4l2.c - csg1k sensor driver
+ *
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/gpio.h>
+#include <linux/module.h>
+
+#include <linux/seq_file.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+
+#include <media/tegra-v4l2-camera.h>
+#include <media/camera_common.h>
+#include <media/csg1k.h>
+
+#include "../platform/tegra/camera/camera_gpio.h"
+
+#include "csg1k_mode_tbls.h"
+#include "csg1k_pmic_tbls.h"
+#define CSG1K_MAX_COARSE_DIFF		6
+
+#define CSG1K_GAIN_SHIFT		8
+#define CSG1K_MIN_GAIN		(1 << CSG1K_GAIN_SHIFT)
+#define CSG1K_MAX_GAIN		(16 << CSG1K_GAIN_SHIFT)
+#define CSG1K_MAX_UNREAL_GAIN	(0x0F80)
+#define CSG1K_MIN_FRAME_LENGTH	(0x0)
+#define CSG1K_MAX_FRAME_LENGTH	(0x7fff)
+#define CSG1K_MIN_EXPOSURE_COARSE	(0x0002)
+#define CSG1K_MAX_EXPOSURE_COARSE	\
+	(CSG1K_MAX_FRAME_LENGTH-CSG1K_MAX_COARSE_DIFF)
+#define CSG1K_DEFAULT_LINE_LENGTH	(0xA80)
+#define CSG1K_DEFAULT_PIXEL_CLOCK	(160)
+
+#define CSG1K_DEFAULT_GAIN		CSG1K_MIN_GAIN
+#define CSG1K_DEFAULT_FRAME_LENGTH	(0x07C0)
+#define CSG1K_DEFAULT_EXPOSURE_COARSE	\
+	(CSG1K_DEFAULT_FRAME_LENGTH-CSG1K_MAX_COARSE_DIFF)
+
+
+#define CSG1K_USE_0 0x01
+#define CSG1K_USE_1 0x02
+
+#define NANO 1
+#define TX2 0
+#define CAM_MUX_GPIO 64
+struct csg1k {
+	struct camera_common_power_rail	power;
+	int				numctrls;
+	struct v4l2_ctrl_handler	ctrl_handler;
+	struct i2c_client		*i2c_client;
+	struct v4l2_subdev		*subdev;
+	struct media_pad		pad;
+    	u8 i2c_type;
+    	u8 i2c_slave;
+    	u16 i2c_addr;
+    	u8 i2c_sensor_addr;
+    	u8 bpp;
+    	u8 platform;
+	s32				group_hold_prev;
+	u32				frame_length;
+	bool				group_hold_en;
+	struct regmap			*regmap;
+	struct camera_common_data	*s_data;
+	struct camera_common_pdata	*pdata;
+	struct v4l2_ctrl		*ctrls[];
+};
+
+u8 platform_tmp=0;
+static struct regmap_config csg1k_regmap_config = {
+	.reg_bits = 16,
+	.val_bits = 8,
+};
+
+//static int csg1k_g_volatile_ctrl(struct v4l2_ctrl *ctrl);
+static int csg1k_s_ctrl(struct v4l2_ctrl *ctrl);
+
+
+
+static const struct v4l2_ctrl_ops csg1k_ctrl_ops = {
+	//.g_volatile_ctrl = csg1k_g_volatile_ctrl,
+	.s_ctrl		= csg1k_s_ctrl,
+};
+
+static struct v4l2_ctrl_config ctrl_config_list[] = {
+/* Do not change the name field for the controls! */
+	{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GAIN,
+		.name = "Gain",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = CSG1K_MIN_GAIN,
+		.max = CSG1K_MAX_GAIN,
+		.def = CSG1K_DEFAULT_GAIN,
+		.step = 1,
+	},
+	{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_FRAME_LENGTH,
+		.name = "Frame Length",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = CSG1K_MIN_FRAME_LENGTH,
+		.max = CSG1K_MAX_FRAME_LENGTH,
+		.def = CSG1K_DEFAULT_FRAME_LENGTH,
+		.step = 1,
+	},
+	{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_COARSE_TIME,
+		.name = "Coarse Time",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = CSG1K_MIN_EXPOSURE_COARSE,
+		.max = CSG1K_MAX_EXPOSURE_COARSE,
+		.def = CSG1K_DEFAULT_EXPOSURE_COARSE,
+		.step = 1,
+	},
+	{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_GROUP_HOLD,
+		.name = "Group Hold",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+	{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_HDR_EN,
+		.name = "HDR enable",
+		.type = V4L2_CTRL_TYPE_INTEGER_MENU,
+		.min = 0,
+		.max = ARRAY_SIZE(switch_ctrl_qmenu) - 1,
+		.menu_skip_mask = 0,
+		.def = 0,
+		.qmenu_int = switch_ctrl_qmenu,
+	},
+    {
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_CID_EEPROM_DATA,
+		.name = "EEPROM Data",
+		.type = V4L2_CTRL_TYPE_STRING,
+		.flags = V4L2_CTRL_FLAG_VOLATILE,
+		.min = 0,
+		.max = 2,
+		.step = 2,
+	},
+	{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_BRIGHTNESS_TEST,
+		.name = "brightness",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 100,
+		.def = 5,
+		.step = 1,
+	},
+	{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_CONTRAST_TEST,
+		.name = "Contrast",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 100,
+		.def = 6,
+		.step = 1,
+	},
+	{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_GAMMA_TEST,
+		.name = "Gamma",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 100,
+		.def = 7,
+		.step = 1,
+	},
+		{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_USER_TEST,
+		.name = "rst_sensor",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 3,
+		.def = 0,
+		.step = 1,
+	},
+		{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_USER_TEST3,
+		.name = "power_on",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 2,
+		.def = 0,
+		.step = 1,
+	},
+		{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_USER_TEST4,
+		.name = "power_off",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = V4L2_CTRL_FLAG_SLIDER,
+		.min = 0,
+		.max = 2,
+		.def = 0,
+		.step = 1,
+	},
+		{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_USER_TEST5,
+		.name = "addr_reg_int",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = 0,
+		.min = 0,
+		.max = 0x7FFFFFFF,
+		.def = 0,
+		.step = 1,
+	},
+		{
+		.ops = &csg1k_ctrl_ops,
+		.id = TEGRA_CAMERA_USER_TEST6,
+		.name = "rw_reg_int",
+		.type = V4L2_CTRL_TYPE_INTEGER,
+		.flags = 0,
+		.min = 0,
+		.max = 0x7FFFFFFF,
+		.def = 0,
+		.step = 1,
+	},
+	
+};
+
+
+
+
+
+
+
+
+
+
+
+
+static int test_mode;
+module_param(test_mode, int, 0644);
+
+static inline int csg1k_read_reg(struct camera_common_data *s_data,
+				u16 addr, u8 *val)
+{
+	struct csg1k *priv = (struct csg1k *)s_data->priv;
+	int err = 0;
+	u32 reg_val = 0;
+
+	err = regmap_read(priv->regmap, addr, &reg_val);
+	*val = reg_val & 0xFF;
+
+	return err;
+}
+
+static int csg1k_write_reg(struct camera_common_data *s_data, u16 addr, u8 val)
+{
+	int err;
+	struct csg1k *priv = (struct csg1k *)s_data->priv;
+
+	err = regmap_write(priv->regmap, addr, val);
+	if (err)
+		pr_err("%s:i2c write failed, %x = %x\n",
+			__func__, addr, val);
+
+	return err;
+}
+
+
+
+static int csg1k_sensor_write_reg(struct camera_common_data *s_data, u8 devid, u16 addr, u16 val, u8 dtype)
+{
+    int err = 0;
+    struct i2c_client * my_client=NULL; 
+    struct i2c_msg msgs[1];
+    struct i2c_adapter * my_adap=NULL;
+
+    u8 buf[4];
+    if(platform_tmp==NANO){
+	  my_adap = i2c_get_adapter(6); // nr i2c bus number
+     }else {
+	  my_adap = i2c_get_adapter(2); // nr i2c bus number
+	}
+  
+	my_client = i2c_new_dummy (my_adap, devid); 
+	if(my_client==NULL) {
+		printk(KERN_INFO "[csg1k]: unable to init I2C\n");
+		return 1;
+	}
+    
+    if(dtype == 0) {
+        // reg=8bit, val=8bit
+        msgs[0].addr = (u8)(my_client->addr & 0xFF);
+        msgs[0].flags = 0;
+        msgs[0].len = 2;
+        msgs[0].buf = buf;
+        buf[0] = addr & 0xFF;
+        buf[1] = val;
+    } else if(dtype == 1) {
+        // reg=16bit, val=8bit
+        msgs[0].addr = (u8)(my_client->addr & 0xFF);
+        msgs[0].flags = 0;
+        msgs[0].len = 3;
+        msgs[0].buf = buf;
+        buf[0] = (addr >> 8) & 0xFF;
+        buf[1] = addr & 0xFF;
+        buf[2] = val;        
+    } else if(dtype == 2) {
+        // reg=8bit, val=16bit
+        msgs[0].addr = (u8)(my_client->addr & 0xFF);
+        msgs[0].flags = 0;
+        msgs[0].len = 3;
+        msgs[0].buf = buf;
+        buf[0] = addr & 0xFF;
+        buf[1] = (val >> 8) & 0xFF;
+        buf[2] = val & 0xFF;
+    } else {
+        // reg=16bit, val=16bit
+        msgs[0].addr = (u8)(my_client->addr & 0xFF);
+        msgs[0].flags = 0;
+        msgs[0].len = 4;
+        msgs[0].buf = buf;
+        buf[0] = (addr >> 8) & 0xFF;
+        buf[1] = addr & 0xFF;
+        buf[2] = (val >> 8) & 0xFF;
+        buf[3] = val & 0xFF;
+    }
+
+    err = i2c_transfer(my_client->adapter, msgs, 1);
+    i2c_unregister_device(my_client);
+    return err;
+}
+
+static int csg1k_sensor_read_reg(struct camera_common_data *s_data, u8 devid, u16 addr, u16 *val, u8 dtype)
+{
+    int err = 0;
+
+    struct i2c_msg msgs[2];
+    u8 buf[4];
+    struct i2c_client * my_client=NULL; 
+    struct i2c_adapter * my_adap= NULL;
+	if(platform_tmp==NANO){
+		my_adap = i2c_get_adapter(6); // nr i2c bus number
+	}else {
+		my_adap = i2c_get_adapter(2); // nr i2c bus number
+	}
+
+	my_client = i2c_new_dummy (my_adap, devid); 
+	if(my_client==NULL) {
+		printk(KERN_INFO "[csg1k]: unable to init I2C\n");
+		return 1;
+	}
+
+    if(dtype == 0) {
+        // reg=8bit, val=8bit
+        msgs[0].addr = (u8)(my_client->addr & 0xFF);
+        msgs[0].flags = 0;
+        msgs[0].len = 1;
+        msgs[0].buf = buf;
+        buf[0] = (u8)(addr & 0xFF);
+        msgs[1].addr = (u8)(my_client->addr & 0xFF);
+        msgs[1].flags = I2C_M_RD;
+        msgs[1].len = 1;
+        msgs[1].buf = buf;
+    } else if(dtype == 1) {
+        // reg=16bit, val=8bit
+        msgs[0].addr = (u8)(my_client->addr & 0xFF);
+        msgs[0].flags = 0;
+        msgs[0].len = 2;
+        msgs[0].buf = buf;
+        buf[0] = (u8)((addr >> 8) & 0xFF);
+        buf[1] = (u8)(addr & 0xFF);
+        msgs[1].addr = (u8)(my_client->addr & 0xFF);
+        msgs[1].flags = I2C_M_RD;
+        msgs[1].len = 1;
+        msgs[1].buf = buf;
+    } else if(dtype == 2) {
+        // reg=8bit, val=16bit
+        msgs[0].addr = (u8)(my_client->addr & 0xFF);
+        msgs[0].flags = 0;
+        msgs[0].len = 1;
+        msgs[0].buf = buf;
+        buf[0] = (u8)(addr & 0xFF);
+        msgs[1].addr = (u8)(my_client->addr & 0xFF);
+        msgs[1].flags = I2C_M_RD;
+        msgs[1].len = 2;
+        msgs[1].buf = buf;
+    } else { // type=3
+        // reg=16bit, val=16bit
+        msgs[0].addr = (u8)(my_client->addr & 0xFF);
+        msgs[0].flags = 0;
+        msgs[0].len = 2;
+        msgs[0].buf = buf;
+        buf[0] = (u8)((addr >> 8) & 0xFF);
+        buf[1] = (u8)(addr & 0xFF);
+        msgs[1].addr = (u8)(my_client->addr & 0xFF);
+        msgs[1].flags = I2C_M_RD;
+        msgs[1].len = 2;
+        msgs[1].buf = buf;
+    }
+
+    err = i2c_transfer(my_client->adapter, msgs, 2);
+    i2c_unregister_device(my_client);
+
+    if (msgs[1].len == 1) {
+        *val = buf[0] & 0xFF;
+    } else {
+        *val = (((u16)(buf[0])) << 8) + buf[1];
+    }
+    
+	if (err < 0) {
+		return err;
+    }
+
+	return 0;
+}
+
+
+static void csg1k_gpio_set(struct csg1k *priv,
+			    unsigned int gpio, int val)
+{
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_ctrl(&priv->i2c_client->dev, gpio, val, 1);
+	else {
+		if (gpio_cansleep(gpio))
+			gpio_set_value_cansleep(gpio, val);
+		else
+			gpio_set_value(gpio, val);
+	}
+}
+
+
+
+static int csg1k_reset(struct csg1k *priv, int mode)
+{
+	
+	struct camera_common_power_rail *pw = &priv->power;
+
+
+	if(mode==2){ //keep in reset
+		if (pw->reset_gpio)
+			csg1k_gpio_set(priv, pw->reset_gpio, 0);
+		return 0;
+	}
+	if(mode==3){ //leave reset
+		if (pw->reset_gpio)
+			csg1k_gpio_set(priv, pw->reset_gpio, 1);
+		return 0;
+	}	
+
+	if (pw->reset_gpio) //toggle reste
+			csg1k_gpio_set(priv, pw->reset_gpio, 0);
+
+		usleep_range(2000, 2010); //2ms
+
+	if (pw->reset_gpio)
+			csg1k_gpio_set(priv, pw->reset_gpio, 1);	
+	return 0;
+}
+
+
+
+
+static int csg1k_power_on(struct camera_common_data *s_data)
+{
+	static int powered_on = 0; // shows if device already powered on
+	int err = 0;
+	struct csg1k *priv = (struct csg1k *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	u32 frame_time;
+
+	err = clk_set_rate(pw->mclk, priv->s_data->def_clk_freq); 
+//	err = clk_set_rate(pw->mclk, 12500000); // csg1k
+//	err = clk_set_rate(pw->mclk, 24000000); // cgss130
+	if (err) {
+		printk(KERN_ERR "[csg1k]: Unable to set mclk frequency\n");
+	}
+	err = clk_get_rate(pw->mclk);
+	
+	if(powered_on) {
+		return 0;
+	} else {
+		powered_on = 1;
+	}
+	
+	dev_dbg(&priv->i2c_client->dev, "%s: power on\n", __func__);
+	if (priv->pdata && priv->pdata->power_on) {
+		err = priv->pdata->power_on(pw);
+		if (err)
+			pr_err("%s failed.\n", __func__);
+		else
+			pw->state = SWITCH_ON;
+		return err;
+	}
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+	
+
+	//if (pw->dvdd)
+	//	err = regulator_enable(pw->dvdd);
+	//if (err)
+	//	goto csg1k_dvdd_fail;
+	if(priv->platform!=NANO){
+
+	if (pw->avdd)
+		err = regulator_enable(pw->avdd);
+	if (err)
+		goto csg1k_avdd_fail;
+
+	if (pw->iovdd)
+		err = regulator_enable(pw->iovdd);
+	if (err)
+		goto csg1k_iovdd_fail;
+
+
+	}
+	usleep_range(1, 2);
+	if (pw->pwdn_gpio)
+		csg1k_gpio_set(priv, pw->pwdn_gpio, 1);
+
+	
+	// tps65912_init(2,1);
+
+	/*
+	 * datasheet 2.9: reset requires ~2ms settling time
+	 * a power on reset is generated after core power becomes stable
+	 */
+	usleep_range(2000, 2010);
+
+	if (pw->reset_gpio)
+		csg1k_gpio_set(priv, pw->reset_gpio, 1);
+
+	/* datasheet fig 2-9: t3 */
+	usleep_range(2000, 2010);
+
+	pw->state = SWITCH_ON;
+
+
+	frame_time = CSG1K_DEFAULT_FRAME_LENGTH *
+			CSG1K_DEFAULT_LINE_LENGTH / CSG1K_DEFAULT_PIXEL_CLOCK;
+	usleep_range(frame_time, frame_time + 1000);
+
+	return 0;
+
+csg1k_iovdd_fail:
+	regulator_disable(pw->avdd);
+	printk(KERN_ERR "[csg1k]: iovdd error\n");
+csg1k_avdd_fail:
+	pr_err("%s failed.\n", __func__);
+	printk(KERN_ERR "[csg1k]: avdd error\n");
+	return -ENODEV;
+}
+
+static int csg1k_power_off(struct camera_common_data *s_data)
+{
+
+	int err = 0;
+	struct csg1k *priv = (struct csg1k *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+
+	// TODO: we do not switch off the power for easier debugging
+	return 0;
+
+	dev_dbg(&priv->i2c_client->dev, "%s: power off\n", __func__);
+	if (priv->pdata && priv->pdata->power_off) {
+		err = priv->pdata->power_off(pw);
+		if (!err) {
+			goto power_off_done;
+		} else {
+			pr_err("%s failed.\n", __func__);
+			return err;
+		}
+	}
+
+	/* sleeps calls in the sequence below are for internal device
+	 * signal propagation as specified by sensor vendor */
+	// tps65912_init(2,0);
+	usleep_range(21, 25);
+	if (pw->pwdn_gpio)
+		csg1k_gpio_set(priv, pw->pwdn_gpio, 0);
+	usleep_range(1, 2);
+	if (pw->reset_gpio)
+		csg1k_gpio_set(priv, pw->reset_gpio, 0);
+
+	/* datasheet 2.9: reset requires ~2ms settling time*/
+	usleep_range(2000, 2010);
+		if(priv->platform!=NANO){
+			if (pw->iovdd)
+				regulator_disable(pw->iovdd);
+			if (pw->avdd)
+				regulator_disable(pw->avdd);
+			/*if (pw->dvdd)
+				regulator_disable(pw->dvdd);*/
+		}
+power_off_done:
+	pw->state = SWITCH_OFF;
+	return 0;
+}
+
+static int csg1k_power_put(struct csg1k *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+
+	if(priv->platform!=NANO){
+		if (unlikely(!pw))
+			return -EFAULT;
+
+		if (likely(pw->avdd))
+			regulator_put(pw->avdd);
+
+		if (likely(pw->iovdd))
+			regulator_put(pw->iovdd);
+	}
+	pw->avdd = NULL;
+	pw->iovdd = NULL;
+
+	if (priv->pdata && priv->pdata->use_cam_gpio)
+		cam_gpio_deregister(&priv->i2c_client->dev, pw->pwdn_gpio);
+	else {
+		gpio_free(pw->pwdn_gpio);
+		gpio_free(pw->reset_gpio);
+	}
+	
+	return 0;
+}
+
+static int csg1k_power_get(struct csg1k *priv)
+{
+	struct camera_common_power_rail *pw = &priv->power;
+	struct camera_common_pdata *pdata = priv->pdata;
+	const char *mclk_name;
+	const char *parentclk_name;
+	struct clk *parent;
+	int err = 0, ret = 0;
+
+	
+	if (!pdata) {
+		dev_err(&priv->i2c_client->dev, "pdata missing\n");
+		return -EFAULT;
+	}
+
+	mclk_name = pdata->mclk_name ?
+		    pdata->mclk_name : "cam_mclk1";
+	pw->mclk = devm_clk_get(&priv->i2c_client->dev, mclk_name);
+	if (IS_ERR(pw->mclk)) {
+		dev_err(&priv->i2c_client->dev,
+			"unable to get clock %s\n", mclk_name);
+		return PTR_ERR(pw->mclk);
+	}
+
+	parentclk_name = pdata->parentclk_name;
+	if (parentclk_name) {
+		parent = devm_clk_get(&priv->i2c_client->dev, parentclk_name);
+		if (IS_ERR(parent)) {
+			dev_err(&priv->i2c_client->dev,
+				"unable to get parent clcok %s",
+				parentclk_name);
+		} else
+			clk_set_parent(pw->mclk, parent);
+	}
+
+	if(priv->platform==NANO){
+		err=0;
+		pw->reset_gpio = pdata->reset_gpio;
+		pw->pwdn_gpio = pdata->pwdn_gpio;
+	}else {
+		/* analog 2.8v */
+		err |= camera_common_regulator_get(&priv->i2c_client->dev,
+				&pw->avdd, pdata->regulators.avdd);
+		/* digital 1.2v 
+		err |= camera_common_regulator_get(&priv->i2c_client->dev,
+				&pw->dvdd, pdata->regulators.dvdd);*/
+		/* IO 1.8v */
+		err |= camera_common_regulator_get(&priv->i2c_client->dev,
+				&pw->iovdd, pdata->regulators.iovdd);
+
+		if (!err) {
+			pw->reset_gpio = pdata->reset_gpio;
+			pw->pwdn_gpio = pdata->pwdn_gpio;
+		}
+	}
+	if (pdata->use_cam_gpio) {
+		err = cam_gpio_register(&priv->i2c_client->dev, pw->pwdn_gpio);
+		if (err)
+			dev_err(&priv->i2c_client->dev,
+				"%s ERR can't register cam gpio %u!\n",
+				 __func__, pw->pwdn_gpio);
+	} else {
+		ret = gpio_request(pw->pwdn_gpio, "cam_pwdn_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request pwdn_gpio %d\n",
+				__func__, ret);
+		ret = gpio_request(pw->reset_gpio, "cam_reset_gpio");
+		if (ret < 0)
+			dev_dbg(&priv->i2c_client->dev,
+				"%s can't request reset_gpio %d\n",
+				__func__, ret);
+	}
+
+
+	pw->state = SWITCH_OFF;
+	return err;
+}
+
+static int csg1k_set_gain(struct csg1k *priv, s32 val);
+static int csg1k_set_frame_length(struct csg1k *priv, s32 val);
+static int csg1k_set_coarse_time(struct csg1k *priv, s32 val);
+
+
+static int csg1k_s_stream(struct v4l2_subdev *sd, int enable)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct csg1k *priv = (struct csg1k *)s_data->priv;
+	struct v4l2_control control;
+	int err;
+	u32 frame_time;
+
+
+	if (!enable) {
+
+		/*
+		 * Wait for one frame to make sure sensor is set to
+		 * software standby in V-blank
+		 *
+		 * frame_time = frame length rows * Tline
+		 * Tline = line length / pixel clock (in MHz)
+		 */
+		frame_time = priv->frame_length *
+			CSG1K_DEFAULT_LINE_LENGTH / CSG1K_DEFAULT_PIXEL_CLOCK;
+
+		usleep_range(frame_time, frame_time + 1000);
+        
+		return 0;
+	}
+	if (s_data->override_enable) {
+		/*
+		 * write list of override regs for the asking frame length,
+		 * coarse integration time, and gain. Failures to write
+		 * overrides are non-fatal
+		 */
+		control.id = TEGRA_CAMERA_CID_GAIN;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= csg1k_set_gain(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning gain override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_FRAME_LENGTH;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= csg1k_set_frame_length(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning frame length override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_CID_COARSE_TIME;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= csg1k_set_coarse_time(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev,
+				"%s: warning coarse time override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_BRIGHTNESS_TEST;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		err |= csg1k_set_gain(priv, control.value);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning BRIGHTNESS override failed\n",
+				__func__);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning CONTRAST override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_GAMMA_TEST;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning GAMMA override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_USER_TEST;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning USER_TEST override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_USER_TEST3;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning USER_TEST override failed\n",
+				__func__);
+
+		control.id = TEGRA_CAMERA_USER_TEST4;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning USER_TEST override failed\n",
+				__func__);
+		control.id = TEGRA_CAMERA_USER_TEST5;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning USER_TEST override failed\n",
+				__func__);
+		control.id = TEGRA_CAMERA_USER_TEST6;
+		err = v4l2_g_ctrl(&priv->ctrl_handler, &control);
+		if (err)
+			dev_dbg(&client->dev, "%s: warning USER_TEST override failed\n",
+				__func__);		
+
+	}
+
+	dev_dbg(&client->dev, "%s--\n", __func__);
+	return 0;
+}
+
+static int csg1k_g_input_status(struct v4l2_subdev *sd, u32 *status)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct csg1k *priv = (struct csg1k *)s_data->priv;
+	struct camera_common_power_rail *pw = &priv->power;
+	*status = pw->state == SWITCH_ON;
+	return 0;
+}
+
+static struct v4l2_subdev_video_ops csg1k_subdev_video_ops = {
+	.s_stream	= csg1k_s_stream,
+	.g_mbus_config	= camera_common_g_mbus_config,
+	.g_input_status = csg1k_g_input_status,
+};
+
+static struct v4l2_subdev_core_ops csg1k_subdev_core_ops = {
+	.s_power	= camera_common_s_power,
+};
+
+static int csg1k_get_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	return camera_common_g_fmt(sd, &format->format);
+}
+
+static int csg1k_set_fmt(struct v4l2_subdev *sd,
+		struct v4l2_subdev_pad_config *cfg,
+		struct v4l2_subdev_format *format)
+{
+	int ret;
+	if (format->which == V4L2_SUBDEV_FORMAT_TRY)
+		ret = camera_common_try_fmt(sd, &format->format);
+	else
+		ret = camera_common_s_fmt(sd, &format->format);
+	return ret;
+}
+
+static struct v4l2_subdev_pad_ops csg1k_subdev_pad_ops = {
+	.set_fmt = csg1k_set_fmt,
+	.get_fmt = csg1k_get_fmt,
+	.enum_mbus_code = camera_common_enum_mbus_code,
+	.enum_frame_size	= camera_common_enum_framesizes,
+	.enum_frame_interval	= camera_common_enum_frameintervals,
+};
+
+static struct v4l2_subdev_ops csg1k_subdev_ops = {
+	.core	= &csg1k_subdev_core_ops,
+	.video	= &csg1k_subdev_video_ops,
+	.pad	= &csg1k_subdev_pad_ops,
+};
+
+static struct of_device_id csg1k_of_match[] = {
+	{ .compatible = "nvidia,csg1k", },
+	{ },
+};
+
+static struct camera_common_sensor_ops csg1k_common_ops = {
+	.power_on = csg1k_power_on,
+	.power_off = csg1k_power_off,
+	.write_reg = csg1k_write_reg,
+	.read_reg = csg1k_read_reg,
+};
+
+static int csg1k_set_group_hold(struct csg1k *priv)
+{
+	int gh_prev = switch_ctrl_qmenu[priv->group_hold_prev];
+
+    
+	if (priv->group_hold_en == true && gh_prev == SWITCH_OFF) {
+		priv->group_hold_prev = 1;
+	} else if (priv->group_hold_en == false && gh_prev == SWITCH_ON) {
+		priv->group_hold_prev = 0;
+	}
+
+	return 0;
+}
+
+
+static int csg1k_set_gain(struct csg1k *priv, s32 val)
+{
+	return 0;
+}
+
+static int csg1k_ctl_rw_register_int(struct csg1k *priv, int currentValue, u16 *val)
+{
+    int err;
+    u16 value = 0;
+    u8 access;
+    u8 tmp;
+    u8 mux_gpio_val=0;
+    struct mutex my_mutex; 
+
+    mutex_init(&my_mutex);
+    value = (u16)(currentValue & 0xFFFF);
+    access = (u8)((currentValue >> 16) & 0xFF);
+    mux_gpio_val=(u8)((currentValue >> 26) & 0x1);
+    
+    if((priv->i2c_addr==0xFFFF)) {
+        return 0;
+    }
+
+    mutex_lock(&my_mutex);
+	    while( (gpio_request(CAM_MUX_GPIO, "cam_mux_gpio"))!=0){usleep_range(3, 5);}
+	    gpio_direction_output(CAM_MUX_GPIO, mux_gpio_val);   
+    
+
+	    if(priv->i2c_slave == priv->i2c_sensor_addr) {
+		if(access) {
+		    err = csg1k_read_reg(priv->s_data, priv->i2c_addr, &tmp);
+		    value = tmp;
+		} else {
+		    tmp = value & 0xFF;
+	    	    err = csg1k_write_reg(priv->s_data, priv->i2c_addr, tmp);
+		}
+	    } else {
+		if(access) {
+		    // read sensor
+			err = csg1k_sensor_read_reg(priv->s_data, priv->i2c_slave, priv->i2c_addr, &value, priv->i2c_type);
+		} else {
+		    // write sensor
+			err = csg1k_sensor_write_reg(priv->s_data, priv->i2c_slave, priv->i2c_addr, value, priv->i2c_type);
+		}
+	    }
+	    gpio_free(CAM_MUX_GPIO);
+    mutex_unlock(&my_mutex);
+    if (err)
+	    goto fail;
+
+    
+	*val=value;
+	return 0;
+
+fail:
+	dev_dbg(&priv->i2c_client->dev,
+		 "%s: read register control error\n", __func__);
+
+	return err;
+}
+
+
+static int csg1k_ctl_addr_register_int(struct csg1k *priv, int currentValue)
+{
+
+    u16 addr;
+    u8 devid;
+    u8 dtype;
+
+    addr = (u16)(currentValue & 0xFFFF);
+    devid = (u8)((currentValue >> 16) & 0xFF);
+    dtype = (u8)((currentValue >> 24) & 0xFF);
+    priv->i2c_addr = addr;
+    priv->i2c_type = dtype;
+    priv->i2c_slave = devid;   
+    return 0;
+}
+
+
+
+
+
+
+
+static int csg1k_set_frame_length(struct csg1k *priv, s32 val)
+{
+	u32 frame_length;  
+	frame_length = (u32)val;
+	priv->frame_length = frame_length;
+	return 0;
+}
+
+static int csg1k_set_coarse_time(struct csg1k *priv, s32 val)
+{
+	return 0;
+}
+
+
+static int csg1k_set_power_debug(struct csg1k *priv)
+{
+	int err;
+	err = camera_common_s_power(priv->subdev, true);
+	if (err){
+		printk(KERN_ERR "[csg1k]: csg1k_set_power_debug error\n");
+		return err;
+
+		}
+	return 0;
+}
+
+
+static int __init csg1k_init_tca(void){
+
+	s32 tmp;
+	int err=0;
+	
+	struct i2c_client * my_client=NULL; 
+
+	struct i2c_adapter * my_adap = i2c_get_adapter(2); // nr i2c bus number
+	printk(KERN_INFO "[csg1k] csg1k_init_tca called\n");
+
+	my_client = i2c_new_dummy (my_adap, 0x70); // tca9546 0x70 - slave address on i2c bus
+	if(my_client==NULL)
+	return 1;
+
+	err = i2c_smbus_write_byte_data(my_client,  CSG1K_USE_0, CSG1K_USE_0); // enable channel
+	if (err)
+		return err;
+
+	tmp=i2c_smbus_read_byte_data (my_client,1);
+
+	printk(KERN_INFO "[csg1k] csg1k_init_tca end\n");
+return 0;
+}
+
+
+
+static int csg1k_s_ctrl(struct v4l2_ctrl *ctrl)
+{
+	u16 tmp=0;
+	struct csg1k *priv =
+		container_of(ctrl->handler, struct csg1k, ctrl_handler);
+	int err = 0;
+
+	if (priv->power.state == SWITCH_OFF)
+		return 0;
+    
+	switch (ctrl->id) {
+	case TEGRA_CAMERA_CID_GAIN:
+		err = csg1k_set_gain(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_FRAME_LENGTH:
+		err = csg1k_set_frame_length(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_COARSE_TIME:
+		err = csg1k_set_coarse_time(priv, ctrl->val);
+		break;
+	case TEGRA_CAMERA_CID_GROUP_HOLD:
+		if (switch_ctrl_qmenu[ctrl->val] == SWITCH_ON) {
+			priv->group_hold_en = true;
+		} else {
+			priv->group_hold_en = false;
+			err = csg1k_set_group_hold(priv);
+		}
+		break;
+    case TEGRA_CAMERA_CID_EEPROM_DATA:
+        break;  
+    case TEGRA_CAMERA_CID_HDR_EN:
+        break;
+	case TEGRA_CAMERA_BRIGHTNESS_TEST:
+		break;	
+	case TEGRA_CAMERA_CONTRAST_TEST:
+		break;
+	case TEGRA_CAMERA_GAMMA_TEST:
+		break;
+	case TEGRA_CAMERA_USER_TEST:
+        if(ctrl->val > 0) {
+		    err = csg1k_reset(priv,ctrl->val);
+		    if(err){
+			    return err;
+		    }
+        }
+		break;
+	case TEGRA_CAMERA_USER_TEST3:
+		break;
+	case TEGRA_CAMERA_USER_TEST4:
+		break;	
+	case TEGRA_CAMERA_USER_TEST5:
+		err = csg1k_ctl_addr_register_int(priv, ctrl->val);
+		if(err){
+			return err;
+		}
+	break;	
+	case TEGRA_CAMERA_USER_TEST6:
+		err = csg1k_ctl_rw_register_int(priv, ctrl->val,&tmp);
+		if(err){
+			return err;
+		}
+		ctrl->val=(int)tmp;
+	break;	
+	default:
+		pr_err("%s: unknown ctrl id.\n", __func__);
+		return -EINVAL;
+	}
+
+	return err;
+}
+
+static int csg1k_ctrls_init(struct csg1k *priv)
+{
+	struct i2c_client *client = priv->i2c_client;
+	struct v4l2_ctrl *ctrl;
+	int numctrls;
+	int err;
+	int i;
+
+	dev_dbg(&client->dev, "%s++\n", __func__);
+
+	numctrls = ARRAY_SIZE(ctrl_config_list);
+	v4l2_ctrl_handler_init(&priv->ctrl_handler, numctrls);
+
+	for (i = 0; i < numctrls; i++) {
+
+
+		ctrl = v4l2_ctrl_new_custom(&priv->ctrl_handler,
+			&ctrl_config_list[i], NULL);
+		if (ctrl == NULL) {
+			dev_err(&client->dev, "Failed to init %s ctrl\n",
+				ctrl_config_list[i].name);
+			continue;
+		}
+
+		if (ctrl_config_list[i].type == V4L2_CTRL_TYPE_STRING &&
+			ctrl_config_list[i].flags & V4L2_CTRL_FLAG_READ_ONLY) {
+			ctrl->p_new.p_char = devm_kzalloc(&client->dev,
+				ctrl_config_list[i].max + 1, GFP_KERNEL);
+			if (!ctrl->p_new.p_char)
+				return -ENOMEM;
+		}
+		priv->ctrls[i] = ctrl;
+	}
+
+	priv->numctrls = numctrls;
+	priv->subdev->ctrl_handler = &priv->ctrl_handler;
+	if (priv->ctrl_handler.error) {
+		dev_err(&client->dev, "Error %d adding controls\n",
+			priv->ctrl_handler.error);
+		err = priv->ctrl_handler.error;
+		goto error;
+	}
+
+	err = v4l2_ctrl_handler_setup(&priv->ctrl_handler);
+	if (err) {
+		dev_err(&client->dev,
+			"Error %d setting default controls\n", err);
+		goto error;
+	}
+	
+	err=csg1k_set_power_debug(priv);
+	return 0;
+
+error:
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	return err;
+}
+
+MODULE_DEVICE_TABLE(of, csg1k_of_match);
+
+static struct camera_common_pdata *csg1k_parse_dt(struct i2c_client *client, struct csg1k *priv)
+{
+	struct device_node *node = client->dev.of_node;
+	struct camera_common_pdata *board_priv_pdata;
+	const struct of_device_id *match;
+	int gpio;
+	int err;
+        u8 bpp;
+    	unsigned long res;
+    	const char *bppstr = NULL;
+    	const char *platformstr = NULL;
+	struct camera_common_pdata *ret = NULL;
+
+
+	if (!node)
+		return NULL;
+
+	match = of_match_device(csg1k_of_match, &client->dev);
+	if (!match) {
+		dev_err(&client->dev, "Failed to find matching dt id\n");
+		return NULL;
+	}
+
+	board_priv_pdata = devm_kzalloc(&client->dev,
+			   sizeof(*board_priv_pdata), GFP_KERNEL);
+	if (!board_priv_pdata)
+		return NULL;
+
+
+	err = of_property_read_string(node, "platform-type",
+			&platformstr);
+	if (err) {
+		dev_err(&client->dev, "platform-type not in DT, use TX2 as default\n");
+		platformstr="";
+		priv->platform = TX2;
+	}
+	if(strcmp(platformstr, "nano")==0){
+		printk(KERN_INFO "[csg1k]: platform-type is jetson nano\n");
+		priv->platform = NANO;
+		printk(KERN_INFO "[csg1k]: pwdn_gpio and reset_gpio is the same GPIO\n");
+		err = camera_common_parse_clocks(&client->dev, board_priv_pdata);
+		if (err) {
+			dev_err(&client->dev, "Failed to find clocks\n");
+			goto error;
+		}
+	
+		gpio = of_get_named_gpio(node, "reset-gpios", 0);
+		if (gpio < 0) {
+			if (gpio == -EPROBE_DEFER) {
+				ret = ERR_PTR(-EPROBE_DEFER);
+				goto error;
+			}
+			dev_err(&client->dev, "reset-gpios not in DT\n");
+			goto error;
+		}
+		board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+		board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+		board_priv_pdata->use_cam_gpio =
+			of_property_read_bool(node, "cam,use-cam-gpio");
+		
+		err = of_property_read_string(node, "avdd-reg",
+				&board_priv_pdata->regulators.avdd);
+
+		err |= of_property_read_string(node, "iovdd-reg",
+				&board_priv_pdata->regulators.iovdd);
+
+		if (err)
+		dev_dbg(&client->dev, "avdd, iovdd and/or dvdd reglers. not present, "
+			"assume sensor powered independently\n");
+
+	}
+	else{
+		printk(KERN_INFO "[csg1k]: platform-type is TX2\n");
+		err = camera_common_parse_clocks(&client->dev, board_priv_pdata);
+		if (err) {
+			dev_err(&client->dev, "Failed to find clocks\n");
+			goto error;
+		}
+
+		gpio = of_get_named_gpio(node, "pwdn-gpios", 0);
+		if (gpio < 0) {
+			if (gpio == -EPROBE_DEFER) {
+				ret = ERR_PTR(-EPROBE_DEFER);
+				goto error;
+			}
+			dev_err(&client->dev, "pwdn gpios not in DT\n");
+			goto error;
+		}
+		board_priv_pdata->pwdn_gpio = (unsigned int)gpio;
+
+		gpio = of_get_named_gpio(node, "reset-gpios", 0);
+		if (gpio < 0) {
+			/* reset-gpio is not absolutely needed */
+			if (gpio == -EPROBE_DEFER) {
+				ret = ERR_PTR(-EPROBE_DEFER);
+				goto error;
+			}
+			dev_dbg(&client->dev, "reset gpios not in DT\n");
+			gpio = 0;
+		}
+		board_priv_pdata->reset_gpio = (unsigned int)gpio;
+
+		board_priv_pdata->use_cam_gpio =
+			of_property_read_bool(node, "cam,use-cam-gpio");
+
+		err = of_property_read_string(node, "avdd-reg",
+				&board_priv_pdata->regulators.avdd);
+		if (err) {
+			dev_err(&client->dev, "avdd-reg not in DT\n");
+			goto error;
+		}
+		err = of_property_read_string(node, "iovdd-reg",
+				&board_priv_pdata->regulators.iovdd);
+		if (err) {
+			dev_err(&client->dev, "iovdd-reg not in DT\n");
+			goto error;
+		}
+	}
+        platform_tmp=priv->platform;
+        board_priv_pdata->v_flip = of_property_read_bool(node, "vertical-flip");
+	board_priv_pdata->h_mirror = of_property_read_bool(node,
+							 "horizontal-mirror");
+
+	err = of_property_read_string(node, "sensor-bpp",
+			&bppstr);
+	if (err) {
+		dev_err(&client->dev, "sensor-bpp not in DT\n");
+		bpp = 8;
+	} else {
+        err = kstrtol(bppstr, 10, &res);
+        if(err) {
+		    dev_err(&client->dev, "sensor-bpp not supported\n");
+            bpp = 8;
+        } else {
+            bpp = (u8)(res & 0xFF);
+        }
+    }
+
+    printk(KERN_INFO "[csg1k]: bpp=%d\n", bpp);
+    priv->bpp = bpp;
+   
+	
+	return board_priv_pdata;
+
+error:
+	devm_kfree(&client->dev, board_priv_pdata);
+	return ret;
+}
+
+static int csg1k_open(struct v4l2_subdev *sd, struct v4l2_subdev_fh *fh)
+{
+	struct i2c_client *client = v4l2_get_subdevdata(sd);
+	dev_dbg(&client->dev, "%s:\n", __func__);
+	return 0;
+}
+
+static const struct v4l2_subdev_internal_ops csg1k_subdev_internal_ops = {
+	.open = csg1k_open,
+};
+
+static const struct media_entity_operations csg1k_media_ops = {
+	.link_validate = v4l2_subdev_link_validate,
+};
+
+
+
+static int csg1k_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct camera_common_data *common_data;
+	struct device_node *node = client->dev.of_node;
+	struct csg1k *priv;
+
+
+	//struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	int err;
+
+	printk(KERN_INFO "[CSG1K]: probing v4l2 sensor.\n");
+	printk(KERN_INFO "[CSG1K]: Driver Version 2.4 29.11.2021.\n");
+
+	if (!IS_ENABLED(CONFIG_OF) || !node)
+		return -EINVAL;
+
+	common_data = devm_kzalloc(&client->dev,
+			    sizeof(struct camera_common_data), GFP_KERNEL);
+	if (!common_data)
+		return -ENOMEM;
+
+	priv = devm_kzalloc(&client->dev,
+			    sizeof(struct csg1k) + sizeof(struct v4l2_ctrl *) *
+			    ARRAY_SIZE(ctrl_config_list),
+			    GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+	priv->regmap = devm_regmap_init_i2c(client, &csg1k_regmap_config);
+	if (IS_ERR(priv->regmap)) {
+		dev_err(&client->dev,
+			"regmap init failed: %ld\n", PTR_ERR(priv->regmap));
+		return -ENODEV;
+	}
+
+	priv->pdata = csg1k_parse_dt(client, priv);
+	printk(KERN_INFO "[csg1k]: csg1k_parse_dt done\n");
+	if (PTR_ERR(priv->pdata) == -EPROBE_DEFER)
+		return -EPROBE_DEFER;
+	if (!priv->pdata) {
+		dev_err(&client->dev, "unable to get platform data\n");
+		return -EFAULT;
+	}
+
+    priv->i2c_client = client;
+    priv->i2c_sensor_addr = client->addr;
+	priv->s_data			= common_data;
+	priv->subdev			= &common_data->subdev;
+	priv->subdev->dev		= &client->dev;
+	priv->s_data->dev		= &client->dev;
+
+    
+    if(client->addr == 0x32) {
+		printk(KERN_INFO "[csg1k]: cgss130 v4l2 setup is used\n");
+		common_data->def_width		= 1080;
+		common_data->def_height		= 1280;
+		common_data->def_mode		= CGSS130_MODE_1080X1280_0;
+		common_data->frmfmt			= cgss130_frmfmt;
+		common_data->numfmts		= ARRAY_SIZE(cgss130_frmfmt);
+		common_data->def_clk_freq	= 24000000;
+    } else if(client->addr == 0x37) {
+		printk(KERN_INFO "[csg1k]: csg1k v4l2 setup is used\n");
+		common_data->def_width		= 1080;
+		common_data->def_height		= 960;
+		common_data->def_mode		= CSG1K_MODE_1080X960_0;
+		common_data->frmfmt			= csg1k_frmfmt;
+		common_data->numfmts		= ARRAY_SIZE(csg1k_frmfmt);
+	common_data->def_clk_freq	= 12750000;
+    }else if(client->addr == 0x54) {
+		printk(KERN_INFO "[csg1k]: cgss220 v4l2 setup is used\n");  // 
+		common_data->def_width		= 1600;
+		common_data->def_height		= 1400;
+		common_data->def_mode		= CGSS220_MODE_1600X1400_0;
+		common_data->frmfmt			= cgss220_frmfmt;
+		common_data->numfmts		= ARRAY_SIZE(cgss220_frmfmt);
+		common_data->def_clk_freq	= 24000000;  //need extern clock ()
+    }else if(client->addr == 0x30) {
+		printk(KERN_INFO "[csg1k]: mira030 v4l2 setup is used\n");  // 
+		common_data->def_width		= 640;
+		common_data->def_height		= 480;
+		common_data->def_mode		= MIRA030_MODE_640X480_0;
+		common_data->frmfmt			= mira030_frmfmt;
+		common_data->numfmts		= ARRAY_SIZE(mira030_frmfmt);
+		common_data->def_clk_freq	= 24000000;
+    }else if(client->addr == 0x36) {
+		printk(KERN_INFO "[csg1k]: mira050 v4l2 setup is used\n");  // 
+		common_data->def_width		= 600;
+		common_data->def_height		= 800;
+		common_data->def_mode		= MIRA050_MODE_600X800_0;
+		common_data->frmfmt			= mira050_frmfmt;
+		common_data->numfmts		= ARRAY_SIZE(mira050_frmfmt);
+		common_data->def_clk_freq	= 24000000;
+    }else if(client->addr == 0x31) {
+		printk(KERN_INFO "[csg1k]: mira uniform v4l2 setup is used\n");  // 
+		common_data->def_width		= 640;
+		common_data->def_height		= 480;
+		common_data->def_mode		= MIRA_MODE_640X480_0;
+		common_data->frmfmt			= mira_frmfmt;
+		common_data->numfmts		= ARRAY_SIZE(mira_frmfmt);
+		common_data->def_clk_freq	= 24000000;
+    }else {
+        printk(KERN_INFO "[csg1k]: unknown sensor\n");
+        return -EFAULT;
+    }
+
+    if(priv->bpp == 8) {
+	    common_data->colorfmt = camera_common_find_datafmt(MEDIA_BUS_FMT_SGRBG8_1X8);
+    } else if(priv->bpp == 10) {
+	    common_data->colorfmt = camera_common_find_datafmt(MEDIA_BUS_FMT_SGRBG10_1X10);
+    } else if(priv->bpp == 12) {
+	    common_data->colorfmt = camera_common_find_datafmt(MEDIA_BUS_FMT_SGRBG12_1X12);
+    } else {        
+        printk(KERN_INFO "[csg1k]: %d bpp is not supported\n", priv->bpp);
+        return -EFAULT;
+    }
+
+    
+	common_data->ops		= &csg1k_common_ops;
+	common_data->ctrl_handler	= &priv->ctrl_handler;
+	common_data->dev		= &client->dev;
+	common_data->power		= &priv->power;
+	common_data->ctrls		= priv->ctrls;
+	common_data->priv		= (void *)priv;
+	common_data->numctrls		= ARRAY_SIZE(ctrl_config_list);
+	common_data->fmt_width		= common_data->def_width;
+	common_data->fmt_height		= common_data->def_height;
+
+    printk(KERN_INFO "[csg1k]: number of modes defined=%2d\n", common_data->numfmts);
+    
+
+	// get power regulator entries and handles from linux
+	err = csg1k_power_get(priv);
+	if (err)
+		return err;
+
+	// do early camera initialization (register driver)
+	printk(KERN_INFO "[csg1k]: camera_common_initialize called\n");
+	err = camera_common_initialize(common_data, "csg1k");
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize csg1k.\n");
+		return err;
+	}
+	printk(KERN_INFO "[csg1k]: camera_common_initialize done\n");
+
+	// Register V4L2 device
+	printk(KERN_INFO "[csg1k]: v4l2_i2c_subdev_init called\n");
+	v4l2_i2c_subdev_init(priv->subdev, client, &csg1k_subdev_ops);
+	printk(KERN_INFO "[csg1k]: v4l2_i2c_subdev_init done\n");
+
+	// Register all V4L2 ioctrls
+	err = csg1k_ctrls_init(priv);
+	if (err) {
+		dev_err(&client->dev, "Failed to initialize csg1k.\n");
+		return err;
+	}
+
+	priv->subdev->internal_ops = &csg1k_subdev_internal_ops;
+	priv->subdev->flags |= V4L2_SUBDEV_FL_HAS_DEVNODE |
+			       V4L2_SUBDEV_FL_HAS_EVENTS;
+
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	printk(KERN_INFO "[csg1k]: CONFIG_MEDIA_CONTROLLER is set\n");
+	priv->pad.flags = MEDIA_PAD_FL_SOURCE;
+//	priv->subdev->entity.type = MEDIA_ENT_T_V4L2_SUBDEV_SENSOR;
+	priv->subdev->entity.function = MEDIA_ENT_F_CAM_SENSOR;//MEDIA_ENT_T_V4L2_SUBDEV_SENSOR; /*Kernel 4.9*/
+	priv->subdev->entity.ops = &csg1k_media_ops;
+	printk(KERN_INFO "[csg1k]: media_entity_init called\n");
+	err = tegra_media_entity_init(&priv->subdev->entity, 1, &priv->pad, true, true);
+	if (err < 0) {
+		dev_err(&client->dev, "unable to init media entity\n");
+		return err;
+	}
+	printk(KERN_INFO "[csg1k]: media_entity_init done\n");
+#endif
+
+	printk(KERN_INFO "[csg1k]: V4L2 registration done\n");
+
+	// reset sensor 
+	csg1k_reset(priv,1);
+
+	// wait until sensor has settled
+	usleep_range(2000, 2010); //2ms
+
+	printk(KERN_INFO "[csg1k]: sensor init (debugging version) done\n");
+
+	printk(KERN_INFO "[csg1k]: V4L2 final registration called\n");
+	err = v4l2_async_register_subdev(priv->subdev);
+	if (err){
+		dev_err(&client->dev, "unable to v4l2_async_register_subdev\n");
+		return err;
+		}
+	printk(KERN_INFO "[csg1k]: V4L2 final registration done\n");
+
+	//printk(KERN_INFO "[csg1k]: csg1k_probe done 24-06-2021\n");
+
+	return 0;
+}
+
+static int
+csg1k_remove(struct i2c_client *client)
+{
+	struct camera_common_data *s_data = to_camera_common_data(&client->dev);
+	struct csg1k *priv = (struct csg1k *)s_data->priv;
+
+	v4l2_async_unregister_subdev(priv->subdev);
+#if defined(CONFIG_MEDIA_CONTROLLER)
+	media_entity_cleanup(&priv->subdev->entity);
+#endif
+
+	v4l2_ctrl_handler_free(&priv->ctrl_handler);
+	csg1k_power_put(priv);
+	camera_common_cleanup(s_data);
+
+	return 0;
+}
+
+static const struct i2c_device_id csg1k_id[] = {
+	{ "csg1k", 0 },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(i2c, csg1k_id);
+
+static struct i2c_driver csg1k_i2c_driver = {
+	.driver = {
+		.name = "csg1k",
+		.owner = THIS_MODULE,
+		.of_match_table = of_match_ptr(csg1k_of_match),
+	},
+	.probe = csg1k_probe,
+	.remove = csg1k_remove,
+	.id_table = csg1k_id,
+};
+
+
+module_i2c_driver(csg1k_i2c_driver);
+module_init(csg1k_init_tca);
+MODULE_DESCRIPTION("SoC Camera driver for ams CSG1K/CGSS130/CGSS220");
+MODULE_AUTHOR("Michael Schmid <mlschmid@schmid-engineering.de>");
+MODULE_LICENSE("GPL v2");
+
diff -ruN kernel_orig/nvidia/drivers/media/i2c/csg1k_mode_tbls.h kernel_ams/nvidia/drivers/media/i2c/csg1k_mode_tbls.h
--- kernel_orig/nvidia/drivers/media/i2c/csg1k_mode_tbls.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel_ams/nvidia/drivers/media/i2c/csg1k_mode_tbls.h	2022-02-03 12:40:17.013840701 +0100
@@ -0,0 +1,639 @@
+/*
+ * csg1k_mode_tbls.h - csg1k sensor mode tables
+ *
+ * Copyright (c) 2015-2017, NVIDIA CORPORATION, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __CSG1K_TABLES__
+#define __CSG1K_TABLES__
+
+#include <media/camera_common.h>
+
+#define CSG1K_TABLE_WAIT_MS	0
+#define CSG1K_TABLE_END	1
+#define CSG1K_MAX_RETRIES	3
+#define CSG1K_WAIT_MS		10
+
+#define csg1k_reg struct reg_8
+
+
+
+enum {
+	CSG1K_MODE_1080X960_0,
+    CSG1K_MODE_1080X960_1,
+};
+
+
+static const int csg1k_fps[] = {
+	15,
+    30,
+};
+
+
+static const struct camera_common_frmfmt csg1k_frmfmt[] = {
+    // Frame Size,  Framerates,     Num Framerates, HDR Enable,  Mode
+	{{1080, 960},	csg1k_fps,	    2,              0,	        CSG1K_MODE_1080X960_0},
+	{{1080, 960},	csg1k_fps,	    2,              0,	        CSG1K_MODE_1080X960_1},
+};
+
+
+
+enum {
+		CGSS130_MODE_1080X1280_0, //10bit
+    		CGSS130_MODE_544X640_1,
+		CGSS130_MODE_1080X1280_2, //8bit
+    		CGSS130_MODE_544X640_3,
+};
+
+
+static const int cgss130_fps30[] = {
+    30,
+};
+
+static const int cgss130_fps60[] = {
+	60,
+};
+
+
+
+
+static const struct camera_common_frmfmt cgss130_frmfmt[] = {
+    // Frame Size,  Framerates,     Num Framerates, HDR Enable,  Mode
+	{{1080, 1280},	cgss130_fps60,	    1,              0,	        CGSS130_MODE_1080X1280_0},//10bit
+	{{544, 640},	cgss130_fps60,	    1,              0,	        CGSS130_MODE_544X640_1},
+	{{1080, 1280},	cgss130_fps60,	    1,              0,	        CGSS130_MODE_1080X1280_2}, //8bit
+	{{544, 640},	cgss130_fps60,	    1,              0,	        CGSS130_MODE_544X640_3},
+};
+
+
+/*     #########cgss220#######       
+enum {
+	CGSS220_MODE_1600X1400_0,
+	CGSS220_MODE_1600X1400_1,
+	CGSS220_MODE_1600X1400_2,
+	CGSS220_MODE_1600X1400_3,
+	CGSS220_MODE_1600X1400_4,
+	CGSS220_MODE_1600X1400_5,  //new for 1 lane
+	CGSS220_MODE_1600X1400_6,
+	CGSS220_MODE_1600X1400_7,
+	CGSS220_MODE_1600X1400_8,
+	CGSS220_MODE_1600X1400_9,
+    //CGSS130_MODE_544X640_2,
+	//CGSS130_MODE_1080X1280_3,
+	//CGSS130_MODE_1080X1280_4,
+    //CGSS130_MODE_544X640_5,
+};
+
+static const int cgss220_fps5[] = {
+    5,
+};
+
+static const int cgss220_fps15[] = {
+	15,
+};
+static const int cgss220_fps30[] = {
+    30,
+};
+
+static const int cgss220_fps60[] = {
+	60,
+};
+static const int cgss220_fps90[] = {
+	90,
+};
+
+static const struct camera_common_frmfmt cgss220_frmfmt[] = {
+    // Frame Size,  Framerates,     Num Framerates, HDR Enable,  Mode
+	{{1600, 1400},	cgss220_fps30,	    1,              0,	        CGSS220_MODE_1600X1400_0},
+	{{1600, 1400},	cgss220_fps60,	    1,              0,	        CGSS220_MODE_1600X1400_1},
+	{{1600, 1400},	cgss220_fps90,	    1,              0,	        CGSS220_MODE_1600X1400_2},
+	{{1600, 1400},	cgss220_fps5,	    1,              0,	        CGSS220_MODE_1600X1400_3},
+	{{1600, 1400},	cgss220_fps15,	    1,              0,	        CGSS220_MODE_1600X1400_4},
+	{{1600, 1400},	cgss220_fps30,	    1,              0,	        CGSS220_MODE_1600X1400_5}, //new for 1 lane
+	{{1600, 1400},	cgss220_fps60,	    1,              0,	        CGSS220_MODE_1600X1400_6},
+	{{1600, 1400},	cgss220_fps90,	    1,              0,	        CGSS220_MODE_1600X1400_7},
+	{{1600, 1400},	cgss220_fps5,	    1,              0,	        CGSS220_MODE_1600X1400_8},
+	{{1600, 1400},	cgss220_fps15,	    1,              0,	        CGSS220_MODE_1600X1400_9},
+//	{{1080, 1280},	cgss130_fps30,	    1,              0,	        CGSS130_MODE_1080X1280_3},
+//	{{1080, 1280},	cgss130_fps60,	    1,              0,	        CGSS130_MODE_1080X1280_4},
+//	{{544, 640},	cgss130_fps60,	    1,              0,	        CGSS130_MODE_544X640_5},
+};
+
+*/
+
+/*     #########cgss220#######       
+enum {
+	CGSS220_MODE_1600X1400_0, //12bit
+	CGSS220_MODE_1600X1400_1,
+	CGSS220_MODE_1600X1400_2,
+	CGSS220_MODE_1600X1400_3,
+	CGSS220_MODE_1600X1400_4,
+	
+	CGSS220_MODE_1280X1120_5,	
+	CGSS220_MODE_1280X1120_6,
+	CGSS220_MODE_1280X1120_7,	
+	CGSS220_MODE_1280X1120_8,
+	CGSS220_MODE_1280X1120_9,
+	
+	CGSS220_MODE_640X480_10,	
+	CGSS220_MODE_640X480_11,
+	CGSS220_MODE_640X480_12,	
+	CGSS220_MODE_640X480_13,
+	CGSS220_MODE_640X480_14,
+	
+
+	CGSS220_MODE_1600X1400_15, //10bit
+	CGSS220_MODE_1600X1400_16,
+	CGSS220_MODE_1600X1400_17,
+	CGSS220_MODE_1600X1400_18,
+	CGSS220_MODE_1600X1400_19,
+	
+	CGSS220_MODE_1280X1120_20,	
+	CGSS220_MODE_1280X1120_21,
+	CGSS220_MODE_1280X1120_22,	
+	CGSS220_MODE_1280X1120_23,
+	CGSS220_MODE_1280X1120_24,
+	
+	CGSS220_MODE_640X480_25,	
+	CGSS220_MODE_640X480_26,
+	CGSS220_MODE_640X480_27,	
+	CGSS220_MODE_640X480_28,
+	CGSS220_MODE_640X480_29,
+	
+	CGSS220_MODE_1600X1400_30, //8bit
+	CGSS220_MODE_1600X1400_31,
+	CGSS220_MODE_1600X1400_32,
+	CGSS220_MODE_1600X1400_33,
+	CGSS220_MODE_1600X1400_34,
+	
+	CGSS220_MODE_1280X1120_35,	
+	CGSS220_MODE_1280X1120_36,
+	CGSS220_MODE_1280X1120_37,	
+	CGSS220_MODE_1280X1120_38,
+	CGSS220_MODE_1280X1120_39,
+	
+	CGSS220_MODE_640X480_40,	
+	CGSS220_MODE_640X480_41,
+	CGSS220_MODE_640X480_42,	
+	CGSS220_MODE_640X480_43,
+	CGSS220_MODE_640X480_44,
+};
+*/
+
+/*     #########cgss220#######   */     
+enum {
+	CGSS220_MODE_1600X1400_0, //12bit
+	CGSS220_MODE_1280X1120_1,	
+	CGSS220_MODE_640X480_2,
+
+	CGSS220_MODE_1600X1400_3, //10bit
+	CGSS220_MODE_1280X1120_4,	
+	CGSS220_MODE_640X480_5,
+	
+	CGSS220_MODE_1600X1400_6, //8bit
+	CGSS220_MODE_1280X1120_7,	
+	CGSS220_MODE_640X480_8,	
+};
+
+static const int cgss220_fps5[] = {
+    5,
+};
+
+static const int cgss220_fps15[] = {
+	15,
+};
+static const int cgss220_fps30[] = {
+    30,
+};
+
+static const int cgss220_fps60[] = {
+	60,
+};
+static const int cgss220_fps90[] = {
+	90,
+};
+
+static const struct camera_common_frmfmt cgss220_frmfmt[] = {
+    // Frame Size,  Framerates,     Num Framerates, HDR Enable,  Mode
+	{{1600, 1400},	cgss220_fps90,	    1,              0,	        CGSS220_MODE_1600X1400_0}, //12bit
+	{{1280, 1120},	cgss220_fps90,	    1,              0,	        CGSS220_MODE_1280X1120_1},	
+	{{640, 480},	cgss220_fps90,	    1,              0,	        CGSS220_MODE_640X480_2},
+	{{1600, 1400},	cgss220_fps90,	    1,              0,	        CGSS220_MODE_1600X1400_3}, //10bit	
+	{{1280, 1120},	cgss220_fps90,	    1,              0,	        CGSS220_MODE_1280X1120_4},	
+	{{640, 480},	cgss220_fps90,	    1,              0,	        CGSS220_MODE_640X480_5},
+	{{1600, 1400},	cgss220_fps90,	    1,              0,	        CGSS220_MODE_1600X1400_6}, //8bit
+	{{1280, 1120},	cgss220_fps90,	    1,              0,	        CGSS220_MODE_1280X1120_7},	
+	{{640, 480},	cgss220_fps90,	    1,              0,	        CGSS220_MODE_640X480_8},
+};
+
+/*     #########mira030#######       */
+enum {
+	MIRA030_MODE_640X480_0,//12bit
+	MIRA030_MODE_480X360_1,
+	MIRA030_MODE_640X480_2,//10bit
+	MIRA030_MODE_480X360_3,
+	MIRA030_MODE_640X480_4,//8bit
+	MIRA030_MODE_480X360_5,
+	MIRA030_MODE_640X480_6,//1lane 50fps 8bit
+
+};
+
+
+
+static const int mira030_fps30[] = {
+    30,
+};
+
+static const int mira030_fps60[] = {
+	60,
+};
+static const int mira030_fps50[] = {
+	50,
+};
+
+static const struct camera_common_frmfmt mira030_frmfmt[] = {
+    // Frame Size,  Framerates,     Num Framerates, HDR Enable,  Mode
+	{{640, 480},	mira030_fps60,	    1,              0,	        MIRA030_MODE_640X480_0}, //12bit
+	{{480, 360},	mira030_fps60,	    1,              0,	        MIRA030_MODE_480X360_1},
+	{{640, 480},	mira030_fps60,	    1,              0,	        MIRA030_MODE_640X480_2}, //10bit
+	{{480, 360},	mira030_fps60,	    1,              0,	        MIRA030_MODE_480X360_3},
+	{{640, 480},	mira030_fps60,	    1,              0,	        MIRA030_MODE_640X480_4},//8bit
+	{{480, 360},	mira030_fps60,	    1,              0,	        MIRA030_MODE_480X360_5},
+	{{640, 480},	mira030_fps50,	    1,              0,	        MIRA030_MODE_640X480_6},//1lane 50fps 8bit
+};
+
+
+/*     #########mira030#######       */
+enum {
+	
+	
+	
+	MIRA050_MODE_600X800_0,//12bit
+	MIRA050_MODE_480X640_1,
+	MIRA050_MODE_600X800_2,//10bit
+	MIRA050_MODE_480X640_3,
+	MIRA050_MODE_600X800_4,//8bit
+	MIRA050_MODE_480X640_5,
+
+};
+
+
+
+
+
+static const int mira050_fps60[] = {
+	60,
+};
+
+
+static const int mira050_fps120[] = {
+	120,
+};
+
+static const int mira050_fps200[] = {
+	200,
+};
+
+static const int mira050_fps300[] = {
+	300,
+};
+
+static const struct camera_common_frmfmt mira050_frmfmt[] = {
+    // Frame Size,  Framerates,     Num Framerates, HDR Enable,  Mode
+	{{600, 800},	mira050_fps200,	    1,              0,	        MIRA050_MODE_600X800_0}, //12bit
+	{{480, 640},	mira050_fps200,	    1,              0,	        MIRA050_MODE_480X640_1},
+	{{600, 800},	mira050_fps200,	    1,              0,	        MIRA050_MODE_600X800_2},//10bit
+	{{480, 640},	mira050_fps200,	    1,              0,	        MIRA050_MODE_480X640_3},	
+	{{600, 800},	mira050_fps200,	    1,              0,	        MIRA050_MODE_600X800_4}, //8bit
+	{{480, 640},	mira050_fps200,	    1,              0,	        MIRA050_MODE_480X640_5}, 
+};
+
+
+//#######################################################################
+
+
+
+//mira one kernel
+
+
+/*     #########miraXXX#######       */
+
+enum {
+	/*     #########mira030#######       */
+	MIRA_MODE_640X480_0,//12bit
+	MIRA_MODE_640X480_1,
+	MIRA_MODE_480X360_2,
+	MIRA_MODE_480X360_3,
+	MIRA_MODE_640X480_4,//10bit
+	MIRA_MODE_640X480_5, 
+	MIRA_MODE_480X360_6,
+	MIRA_MODE_480X360_7,
+	MIRA_MODE_640X480_8,//8bit
+	MIRA_MODE_640X480_9,
+	MIRA_MODE_480X360_10,
+	MIRA_MODE_480X360_11,
+	MIRA_MODE_640X480_12,//1lane 50fps 8bit	
+	
+/*     #########mira050#######       */	
+	MIRA_MODE_600X800_13,//12bit
+	MIRA_MODE_480X640_14,
+	MIRA_MODE_600X800_15,//10bit
+	MIRA_MODE_480X640_16,
+	MIRA_MODE_600X800_17,//8bit
+	MIRA_MODE_480X640_18,
+	
+/*     #########mira130#######       */	
+	MIRA_MODE_1080X1280_19, //10bit
+	MIRA_MODE_1080X1280_20,
+    MIRA_MODE_544X640_21,
+	MIRA_MODE_544X640_22,
+	MIRA_MODE_1080X1280_23,//8bit
+	MIRA_MODE_1080X1280_24,
+    MIRA_MODE_544X640_25,
+	MIRA_MODE_544X640_26,
+
+/*     #########mira220#######       */		
+	MIRA_MODE_1600X1400_27, //12bit
+	MIRA_MODE_1600X1400_28,
+	MIRA_MODE_1600X1400_29,
+	MIRA_MODE_1600X1400_30,
+	MIRA_MODE_1600X1400_31,
+	
+	MIRA_MODE_1280X1120_32,	
+	MIRA_MODE_1280X1120_33,
+	MIRA_MODE_1280X1120_34,	
+	MIRA_MODE_1280X1120_35,
+	MIRA_MODE_1280X1120_36,
+	
+	MIRA_MODE_640X480_37,	
+	MIRA_MODE_640X480_38,
+	MIRA_MODE_640X480_39,	
+	MIRA_MODE_640X480_40,
+	MIRA_MODE_640X480_41,
+	
+	MIRA_MODE_1600X1400_42, //10bit
+	MIRA_MODE_1600X1400_43,
+	MIRA_MODE_1600X1400_44,
+	MIRA_MODE_1600X1400_45,
+	MIRA_MODE_1600X1400_46,
+	
+	MIRA_MODE_1280X1120_47,	
+	MIRA_MODE_1280X1120_48,
+	MIRA_MODE_1280X1120_49,	
+	MIRA_MODE_1280X1120_50,
+	MIRA_MODE_1280X1120_51,
+	
+	MIRA_MODE_640X480_52,	
+	MIRA_MODE_640X480_53,
+	MIRA_MODE_640X480_54,	
+	MIRA_MODE_640X480_55,
+	MIRA_MODE_640X480_56,
+	
+	MIRA_MODE_1600X1400_57, //8bit
+	MIRA_MODE_1600X1400_58,
+	MIRA_MODE_1600X1400_59,
+	MIRA_MODE_1600X1400_60,
+	MIRA_MODE_1600X1400_61,
+	
+	MIRA_MODE_1280X1120_62,	
+	MIRA_MODE_1280X1120_63,
+	MIRA_MODE_1280X1120_64,	
+	MIRA_MODE_1280X1120_65,
+	MIRA_MODE_1280X1120_66,
+	
+	MIRA_MODE_640X480_67,	
+	MIRA_MODE_640X480_68,
+	MIRA_MODE_640X480_69,	
+	MIRA_MODE_640X480_70,
+	MIRA_MODE_640X480_71,	
+
+	/* 1 lane */
+	MIRA_MODE_1600X1400_72, //12bit
+	MIRA_MODE_1600X1400_73,
+	MIRA_MODE_1600X1400_74,
+	MIRA_MODE_1600X1400_75,
+	MIRA_MODE_1600X1400_76,
+	
+	MIRA_MODE_1280X1120_77,	
+	MIRA_MODE_1280X1120_78,
+	MIRA_MODE_1280X1120_79,	
+	MIRA_MODE_1280X1120_80,
+	MIRA_MODE_1280X1120_81,
+	
+	MIRA_MODE_640X480_82,	
+	MIRA_MODE_640X480_83,
+	MIRA_MODE_640X480_84,	
+	MIRA_MODE_640X480_85,
+	MIRA_MODE_640X480_86,
+	
+	MIRA_MODE_1600X1400_87, //10bit
+	MIRA_MODE_1600X1400_88,
+	MIRA_MODE_1600X1400_89,
+	MIRA_MODE_1600X1400_90,
+	MIRA_MODE_1600X1400_91,
+	
+	MIRA_MODE_1280X1120_92,	
+	MIRA_MODE_1280X1120_93,
+	MIRA_MODE_1280X1120_94,	
+	MIRA_MODE_1280X1120_95,
+	MIRA_MODE_1280X1120_96,
+	
+	MIRA_MODE_640X480_97,	
+	MIRA_MODE_640X480_98,
+	MIRA_MODE_640X480_99,	
+	MIRA_MODE_640X480_100,
+	MIRA_MODE_640X480_101,
+	
+	MIRA_MODE_1600X1400_102, //8bit
+	MIRA_MODE_1600X1400_103,
+	MIRA_MODE_1600X1400_104,
+	MIRA_MODE_1600X1400_105,
+	MIRA_MODE_1600X1400_106,
+	
+	MIRA_MODE_1280X1120_107,	
+	MIRA_MODE_1280X1120_108,
+	MIRA_MODE_1280X1120_109,	
+	MIRA_MODE_1280X1120_110,
+	MIRA_MODE_1280X1120_111,
+	
+	MIRA_MODE_640X480_112,	
+	MIRA_MODE_640X480_113,
+	MIRA_MODE_640X480_114,	
+	MIRA_MODE_640X480_115,
+	MIRA_MODE_640X480_116,
+	
+};
+
+
+
+
+
+
+static const int mira_fps5[] = {
+    5,
+};
+
+static const int mira_fps15[] = {
+	15,
+};
+static const int mira_fps30[] = {
+    30,
+};
+
+static const int mira_fps60[] = {
+	60,
+};
+static const int mira_fps50[] = {
+	50,
+};
+
+static const int mira_fps90[] = {
+	90,
+};
+static const struct camera_common_frmfmt mira_frmfmt[] = {
+    // Frame Size,  Framerates,     Num Framerates, HDR Enable,  Mode
+		/*     #########mira030#######       */
+	{{640, 480},	mira_fps30,	    1,              0,	        MIRA_MODE_640X480_0}, //12bit
+	{{640, 480},	mira_fps60,	    1,              0,	        MIRA_MODE_640X480_1},
+	{{480, 360},	mira_fps30,	    1,              0,	        MIRA_MODE_480X360_2},
+	{{480, 360},	mira_fps60,	    1,              0,	        MIRA_MODE_480X360_3},
+	{{640, 480},	mira_fps30,	    1,              0,	        MIRA_MODE_640X480_4}, //10bit
+	{{640, 480},	mira_fps60,	    1,              0,	        MIRA_MODE_640X480_5}, 
+	{{480, 360},	mira_fps30,	    1,              0,	        MIRA_MODE_480X360_6},
+	{{480, 360},	mira_fps60,	    1,              0,	        MIRA_MODE_480X360_7},
+	{{640, 480},	mira_fps30,	    1,              0,	        MIRA_MODE_640X480_8},//8bit
+	{{640, 480},	mira_fps60,	    1,              0,	        MIRA_MODE_640X480_9},
+	{{480, 360},	mira_fps30,	    1,              0,	        MIRA_MODE_480X360_10},
+	{{480, 360},	mira_fps60,	    1,              0,	        MIRA_MODE_480X360_11},
+	{{640, 480},	mira_fps50,	    1,              0,	        MIRA_MODE_640X480_12},//1 lane 50fps 8bit	
+		/*     #########mira050#######       */
+	{{600, 800},	mira_fps60,	    1,              0,	        MIRA_MODE_600X800_13}, //12bit
+	{{480, 640},	mira_fps60,	    1,              0,	        MIRA_MODE_480X640_14},
+	{{600, 800},	mira_fps60,	    1,              0,	        MIRA_MODE_600X800_15}, //10bit
+	{{480, 640},	mira_fps60,	    1,              0,	        MIRA_MODE_480X640_16},	
+	{{600, 800},	mira_fps60,	    1,              0,	        MIRA_MODE_600X800_17}, //8bit
+	{{480, 640},	mira_fps60,	    1,              0,	        MIRA_MODE_480X640_18}, 
+		/*     #########mira130#######       */
+	{{1080, 1280},	mira_fps30,	    1,              0,	        MIRA_MODE_1080X1280_19}, //10bit
+	{{1080, 1280},	mira_fps60,	    1,              0,	        MIRA_MODE_1080X1280_20},
+	{{544, 640},	mira_fps30,	    1,              0,	        MIRA_MODE_544X640_21},
+	{{544, 640},	mira_fps60,	    1,              0,	        MIRA_MODE_544X640_22},
+	{{1080, 1280},	mira_fps30,	    1,              0,	        MIRA_MODE_1080X1280_23}, //8bit
+	{{1080, 1280},	mira_fps60,	    1,              0,	        MIRA_MODE_1080X1280_24},
+	{{544, 640},	mira_fps30,	    1,              0,	        MIRA_MODE_544X640_25},
+	{{544, 640},	mira_fps60,	    1,              0,	        MIRA_MODE_544X640_26},	
+		/*     #########mira220#######       */
+	{{1600, 1400},	mira_fps5,	    1,              0,	        MIRA_MODE_1600X1400_27}, //12bit
+	{{1600, 1400},	mira_fps15,	    1,              0,	        MIRA_MODE_1600X1400_28},
+	{{1600, 1400},	mira_fps30,	    1,              0,	        MIRA_MODE_1600X1400_29},
+	{{1600, 1400},	mira_fps60,	    1,              0,	        MIRA_MODE_1600X1400_30},
+	{{1600, 1400},	mira_fps90,	    1,              0,	        MIRA_MODE_1600X1400_31},
+	{{1280, 1120},	mira_fps5,	    1,              0,	        MIRA_MODE_1280X1120_32},
+	{{1280, 1120},	mira_fps15,	    1,              0,	        MIRA_MODE_1280X1120_33},
+	{{1280, 1120},	mira_fps30,	    1,              0,	        MIRA_MODE_1280X1120_34},
+	{{1280, 1120},	mira_fps60,	    1,              0,	        MIRA_MODE_1280X1120_35},
+	{{1280, 1120},	mira_fps90,	    1,              0,	        MIRA_MODE_1280X1120_36},	
+	{{640, 480},	mira_fps5,	    1,              0,	        MIRA_MODE_640X480_37},
+	{{640, 480},	mira_fps15,	    1,              0,	        MIRA_MODE_640X480_38},
+	{{640, 480},	mira_fps30,	    1,              0,	        MIRA_MODE_640X480_39},
+	{{640, 480},	mira_fps60,	    1,              0,	        MIRA_MODE_640X480_40},
+	{{640, 480},	mira_fps90,	    1,              0,	        MIRA_MODE_640X480_41},
+	{{1600, 1400},	mira_fps5,	    1,              0,	        MIRA_MODE_1600X1400_42}, //10bit
+	{{1600, 1400},	mira_fps15,	    1,              0,	        MIRA_MODE_1600X1400_43},
+	{{1600, 1400},	mira_fps30,	    1,              0,	        MIRA_MODE_1600X1400_44},
+	{{1600, 1400},	mira_fps60,	    1,              0,	        MIRA_MODE_1600X1400_45},
+	{{1600, 1400},	mira_fps90,	    1,              0,	        MIRA_MODE_1600X1400_46},
+	{{1280, 1120},	mira_fps5,	    1,              0,	        MIRA_MODE_1280X1120_47},
+	{{1280, 1120},	mira_fps15,	    1,              0,	        MIRA_MODE_1280X1120_48},
+	{{1280, 1120},	mira_fps30,	    1,              0,	        MIRA_MODE_1280X1120_49},
+	{{1280, 1120},	mira_fps60,	    1,              0,	        MIRA_MODE_1280X1120_50},
+	{{1280, 1120},	mira_fps90,	    1,              0,	        MIRA_MODE_1280X1120_51},	
+	{{640, 480},	mira_fps5,	    1,              0,	        MIRA_MODE_640X480_52},
+	{{640, 480},	mira_fps15,	    1,              0,	        MIRA_MODE_640X480_53},
+	{{640, 480},	mira_fps30,	    1,              0,	        MIRA_MODE_640X480_54},
+	{{640, 480},	mira_fps60,	    1,              0,	        MIRA_MODE_640X480_55},
+	{{640, 480},	mira_fps90,	    1,              0,	        MIRA_MODE_640X480_56},
+	{{1600, 1400},	mira_fps5,	    1,              0,	        MIRA_MODE_1600X1400_57}, //8bit
+	{{1600, 1400},	mira_fps15,	    1,              0,	        MIRA_MODE_1600X1400_58},
+	{{1600, 1400},	mira_fps30,	    1,              0,	        MIRA_MODE_1600X1400_59},
+	{{1600, 1400},	mira_fps60,	    1,              0,	        MIRA_MODE_1600X1400_60},
+	{{1600, 1400},	mira_fps90,	    1,              0,	        MIRA_MODE_1600X1400_61},
+	{{1280, 1120},	mira_fps5,	    1,              0,	        MIRA_MODE_1280X1120_62},
+	{{1280, 1120},	mira_fps15,	    1,              0,	        MIRA_MODE_1280X1120_63},
+	{{1280, 1120},	mira_fps30,	    1,              0,	        MIRA_MODE_1280X1120_64},
+	{{1280, 1120},	mira_fps60,	    1,              0,	        MIRA_MODE_1280X1120_65},
+	{{1280, 1120},	mira_fps90,	    1,              0,	        MIRA_MODE_1280X1120_66},	
+	{{640, 480},	mira_fps5,	    1,              0,	        MIRA_MODE_640X480_67},
+	{{640, 480},	mira_fps15,	    1,              0,	        MIRA_MODE_640X480_68},
+	{{640, 480},	mira_fps30,	    1,              0,	        MIRA_MODE_640X480_69},
+	{{640, 480},	mira_fps60,	    1,              0,	        MIRA_MODE_640X480_70},
+	{{640, 480},	mira_fps90,	    1,              0,	        MIRA_MODE_640X480_71},	
+
+		/*1 Lane*/
+	{{1600, 1400},	mira_fps5,	    1,              0,	        MIRA_MODE_1600X1400_72}, //12bit
+	{{1600, 1400},	mira_fps15,	    1,              0,	        MIRA_MODE_1600X1400_73},
+	{{1600, 1400},	mira_fps30,	    1,              0,	        MIRA_MODE_1600X1400_74},
+	{{1600, 1400},	mira_fps60,	    1,              0,	        MIRA_MODE_1600X1400_75},
+	{{1600, 1400},	mira_fps90,	    1,              0,	        MIRA_MODE_1600X1400_76},
+	{{1280, 1120},	mira_fps5,	    1,              0,	        MIRA_MODE_1280X1120_77},
+	{{1280, 1120},	mira_fps15,	    1,              0,	        MIRA_MODE_1280X1120_78},
+	{{1280, 1120},	mira_fps30,	    1,              0,	        MIRA_MODE_1280X1120_79},
+	{{1280, 1120},	mira_fps60,	    1,              0,	        MIRA_MODE_1280X1120_80},
+	{{1280, 1120},	mira_fps90,	    1,              0,	        MIRA_MODE_1280X1120_81},	
+	{{640, 480},	mira_fps5,	    1,              0,	        MIRA_MODE_640X480_82},
+	{{640, 480},	mira_fps15,	    1,              0,	        MIRA_MODE_640X480_83},
+	{{640, 480},	mira_fps30,	    1,              0,	        MIRA_MODE_640X480_84},
+	{{640, 480},	mira_fps60,	    1,              0,	        MIRA_MODE_640X480_85},
+	{{640, 480},	mira_fps90,	    1,              0,	        MIRA_MODE_640X480_86},
+	{{1600, 1400},	mira_fps5,	    1,              0,	        MIRA_MODE_1600X1400_87}, //10bit
+	{{1600, 1400},	mira_fps15,	    1,              0,	        MIRA_MODE_1600X1400_88},
+	{{1600, 1400},	mira_fps30,	    1,              0,	        MIRA_MODE_1600X1400_89},
+	{{1600, 1400},	mira_fps60,	    1,              0,	        MIRA_MODE_1600X1400_90},
+	{{1600, 1400},	mira_fps90,	    1,              0,	        MIRA_MODE_1600X1400_91},
+	{{1280, 1120},	mira_fps5,	    1,              0,	        MIRA_MODE_1280X1120_92},
+	{{1280, 1120},	mira_fps15,	    1,              0,	        MIRA_MODE_1280X1120_93},
+	{{1280, 1120},	mira_fps30,	    1,              0,	        MIRA_MODE_1280X1120_94},
+	{{1280, 1120},	mira_fps60,	    1,              0,	        MIRA_MODE_1280X1120_95},
+	{{1280, 1120},	mira_fps90,	    1,              0,	        MIRA_MODE_1280X1120_96},	
+	{{640, 480},	mira_fps5,	    1,              0,	        MIRA_MODE_640X480_97},
+	{{640, 480},	mira_fps15,	    1,              0,	        MIRA_MODE_640X480_98},
+	{{640, 480},	mira_fps30,	    1,              0,	        MIRA_MODE_640X480_99},
+	{{640, 480},	mira_fps60,	    1,              0,	        MIRA_MODE_640X480_100},
+	{{640, 480},	mira_fps90,	    1,              0,	        MIRA_MODE_640X480_101},
+	{{1600, 1400},	mira_fps5,	    1,              0,	        MIRA_MODE_1600X1400_102}, //8bit
+	{{1600, 1400},	mira_fps15,	    1,              0,	        MIRA_MODE_1600X1400_103},
+	{{1600, 1400},	mira_fps30,	    1,              0,	        MIRA_MODE_1600X1400_104},
+	{{1600, 1400},	mira_fps60,	    1,              0,	        MIRA_MODE_1600X1400_105},
+	{{1600, 1400},	mira_fps90,	    1,              0,	        MIRA_MODE_1600X1400_106},
+	{{1280, 1120},	mira_fps5,	    1,              0,	        MIRA_MODE_1280X1120_107},
+	{{1280, 1120},	mira_fps15,	    1,              0,	        MIRA_MODE_1280X1120_108},
+	{{1280, 1120},	mira_fps30,	    1,              0,	        MIRA_MODE_1280X1120_109},
+	{{1280, 1120},	mira_fps60,	    1,              0,	        MIRA_MODE_1280X1120_110},
+	{{1280, 1120},	mira_fps90,	    1,              0,	        MIRA_MODE_1280X1120_111},	
+	{{640, 480},	mira_fps5,	    1,              0,	        MIRA_MODE_640X480_112},
+	{{640, 480},	mira_fps15,	    1,              0,	        MIRA_MODE_640X480_113},
+	{{640, 480},	mira_fps30,	    1,              0,	        MIRA_MODE_640X480_114},
+	{{640, 480},	mira_fps60,	    1,              0,	        MIRA_MODE_640X480_115},
+	{{640, 480},	mira_fps90,	    1,              0,	        MIRA_MODE_640X480_116},			
+};
+
+
+
+
+
+
+
+#endif  /* __CSG1K_TABLES__ */
+
diff -ruN kernel_orig/nvidia/drivers/media/i2c/csg1k_pmic_tbls.h kernel_ams/nvidia/drivers/media/i2c/csg1k_pmic_tbls.h
--- kernel_orig/nvidia/drivers/media/i2c/csg1k_pmic_tbls.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel_ams/nvidia/drivers/media/i2c/csg1k_pmic_tbls.h	2022-02-03 12:40:17.014840714 +0100
@@ -0,0 +1,349 @@
+/*
+ * csg1k_pmic_tbls.h - csg1k sensor pmic mode tables
+ *
+ * Copyright (c) 2015-2017, NVIDIA CORPORATION, All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __CSG1K_PMIC_TABLES__
+#define __CSG1K_PMIC_TABLES__
+
+
+u8 tps65912_PMIC_Register_mode_Test[103][2] = {
+	{0x00, 0x00},
+	{0x01, 0x00},
+	{0x02, 0x00},
+	{0x03, 0x00},
+	{0x04, 0x00},
+	{0x05, 0x00},
+	{0x06, 0x00},
+	{0x07, 0x00},
+	{0x08, 0x00},
+	{0x09, 0x00},
+	{0x0A, 0x00},
+	{0x0B, 0x00},
+	{0x0C, 0x00},
+	{0x0D, 0x00},
+	{0x0E, 0x00},
+	{0x0F, 0x00},
+	{0x10, 0x00},
+	{0x11, 0x00},
+	{0x12, 0x00},
+	{0x13, 0x00},
+	{0x14, 0x00},
+	{0x15, 0x00},
+	{0x16, 0x00},
+	{0x17, 0x00},
+	{0x18, 0x00},
+	{0x19, 0x00},
+	{0x1A, 0x00},
+	{0x1B, 0x00},
+	{0x1C, 0x00},
+	{0x1D, 0x00},
+	{0x1E, 0x00},
+	{0x1F, 0x00},
+	{0x20, 0x00},
+	{0x21, 0x00},
+	{0x22, 0x00},
+	{0x23, 0x00},
+	{0x24, 0x00}, 	//DEVCTRL (24h) TBD
+	{0x25, 0x00}, 	//DEVCTRL2
+	{0x26, 0x00},
+	{0x27, 0x00},	//KEEP_ON1 (27h) TBD
+	{0x28, 0x00}, 	//KEEP_ON2 (28h) TBD
+	{0x29, 0x00},	//SET_OFF1 (29h) TBD
+	{0x2A, 0x00},	//SET_OFF1 (29h) TBD
+	{0x2B, 0x00},
+	{0x2C, 0x00},
+	{0x2D, 0x00},	//DISCHARGE1 (2Dh) TBD
+	{0x2E, 0x00},	//DISCHARGE1 (2Dh) TBD
+	{0x2F, 0x00},
+	{0x30, 0x00},
+	{0x31, 0x00},
+	{0x32, 0x00},
+	{0x33, 0x00},
+	{0x34, 0x00},
+	{0x35, 0x00},
+	{0x36, 0x00},
+	{0x37, 0x00},
+	{0x38, 0x00},
+	{0x39, 0x00},
+	{0x3A, 0x00},
+	{0x3B, 0x00},
+	{0x3C, 0x00},
+	{0x3D, 0x00},
+	{0x3E, 0x00},
+	{0x3F, 0x00},
+	{0x40, 0x00},
+	{0x41, 0x05},
+	{0x42, 0x00},
+	{0x43, 0x00},
+	{0x44, 0x00},
+	{0x45, 0x00},
+	{0x46, 0x00},
+	{0x47, 0x00},
+	{0x48, 0x00},
+	{0x49, 0x00},
+	{0x4A, 0x00},
+	{0x4B, 0x00},
+	{0x4C, 0x00},
+	{0x4D, 0x00},
+	{0x4E, 0x00},
+	{0x4F, 0x00},
+	{0x50, 0x00},
+	{0x51, 0x00},
+	{0x52, 0x00},
+	{0x53, 0x00},
+	{0x54, 0x00},
+	{0x55, 0x00},
+	{0x56, 0x00},
+	{0x57, 0x00},
+	{0x58, 0x00},
+	{0x59, 0x00},
+	{0x5A, 0x00},
+	{0x5B, 0x00},
+	{0x5C, 0x00},
+	{0x5D, 0x00},
+	{0x5E, 0x00},
+	{0x5F, 0x00},
+	{0x60, 0x00},
+	{0x61, 0x00},
+	{0x62, 0x00},
+	{0x63, 0x00},
+};
+u8 tps65912_PMIC_Register_mode_0[101][2] = {
+	/*{0x00, 0x02},
+	{0x01, 0x00},
+	{0x02, 0x00},
+	{0x03, 0x01},
+	{0x04, 0x0E},
+	{0x05, 0x8E},
+	{0x06, 0xFF},
+	{0x07, 0x00},
+	{0x08, 0x00},
+	{0x09, 0xFF},
+	{0x0A, 0x0E},
+	{0x0B, 0x8E},
+	{0x0C, 0xFF},
+	{0x0D, 0x1A},
+	{0x0E, 0x9A},
+	{0x0F, 0xFF},
+	{0x10, 0x32},
+	{0x11, 0xB2},
+	{0x12, 0x05},
+	{0x13, 0x00},
+	{0x14, 0x00},
+	{0x15, 0x3F},
+	{0x16, 0x00},
+	{0x17, 0x00},
+	{0x18, 0x3C},
+	{0x19, 0x3F},
+	{0x1A, 0xBF},
+	{0x1B, 0x28},
+	{0x1C, 0xBF},
+	{0x1D, 0x00},
+	{0x1E, 0x90},
+	{0x1F, 0x00},
+	{0x20, 0xBF},
+	{0x21, 0xBF},
+	{0x22, 0x0D},
+	{0x23, 0x00},
+	{0x24, 0x00},
+	{0x25, 0x38},
+	{0x26, 0x40},
+	{0x27, 0xE6},
+	{0x28, 0x3B},
+	{0x29, 0x00},
+	{0x2A, 0x00},
+	{0x2B, 0x00},
+	{0x2C, 0x00},
+	{0x2D, 0x00},
+	{0x2E, 0x00},
+	{0x2F, 0x00},
+	{0x30, 0x00},
+	{0x31, 0x00},
+	{0x32, 0x00},
+	{0x33, 0x00},
+	{0x34, 0x00},
+	{0x35, 0x00},
+	{0x36, 0x00},
+	{0x37, 0xF0},
+	{0x38, 0x39},
+	{0x39, 0x80},
+	{0x3A, 0x00},
+	{0x3B, 0x00},
+	{0x3C, 0x00},
+	{0x3D, 0x00},
+	{0x3E, 0x00},
+	{0x3F, 0x00},
+	{0x40, 0x00},
+	{0x41, 0x00},
+	{0x42, 0x00},
+	{0x43, 0x00},
+	{0x44, 0x00},
+	{0x45, 0x00},
+	{0x46, 0x45},
+	{0x47, 0x00},
+	{0x48, 0x00},
+	{0x49, 0x00},
+	{0x4A, 0x00},
+	{0x4B, 0x00},
+	{0x4C, 0x00},
+	{0x4D, 0x00},
+	{0x4E, 0x00},
+	{0x4F, 0x00},
+	{0x50, 0x00},
+	{0x51, 0x00},
+	{0x52, 0x00},
+	{0x53, 0x00},
+	{0x54, 0x00},
+	{0x55, 0x00},
+	{0x56, 0x00},
+	{0x57, 0x00},
+	{0x58, 0x00},
+	{0x59, 0x00},
+	{0x5A, 0x00},
+	{0x5B, 0x00},
+	{0x5C, 0x00},
+	{0x5D, 0x00},
+	{0x5E, 0x00},
+	{0x5F, 0x00},
+	{0x60, 0x00},
+	{0x61, 0x00},
+	{0x62, 0x0d},
+	{0x63, 0x00},
+	{0x64, 0x05},*/
+	{0x00, 0x00},
+	{0x01, 0x00},
+	{0x02, 0x00},
+	{0x03, 0x00},
+	{0x04, 0x00},
+	{0x05, 0x00},
+	{0x06, 0x00},
+	{0x07, 0x00},
+	{0x08, 0x00},
+	{0x09, 0x00},
+	{0x0A, 0x00},
+	{0x0B, 0x00},
+	{0x0C, 0x00},
+	{0x0D, 0x00},
+	{0x0E, 0x00},
+	{0x0F, 0x00},
+	{0x10, 0x00},
+	{0x11, 0x00},
+	{0x12, 0x00},
+	{0x13, 0x00},
+	{0x14, 0x00},
+	{0x15, 0x00},
+	{0x16, 0x00},
+	{0x17, 0x00},
+	{0x18, 0x00},
+	{0x19, 0x00},
+	{0x1A, 0x00},
+	{0x1B, 0x00},
+	{0x1C, 0x00},
+	{0x1D, 0x00},
+	{0x1E, 0x00},
+	{0x1F, 0x00},
+	{0x20, 0x00},
+	{0x21, 0x00},
+	{0x22, 0x00},
+	{0x23, 0x00},
+	{0x24, 0x00}, 	//DEVCTRL (24h) TBD
+	{0x25, 0x00}, 	//DEVCTRL2
+	{0x26, 0x00},
+	{0x27, 0x00},	//KEEP_ON1 (27h) TBD
+	{0x28, 0x00}, 	//KEEP_ON2 (28h) TBD
+	{0x29, 0x00},	//SET_OFF1 (29h) TBD
+	{0x2A, 0x00},	//SET_OFF1 (29h) TBD
+	{0x2B, 0x00},
+	{0x2C, 0x00},
+	{0x2D, 0x00},	//DISCHARGE1 (2Dh) TBD
+	{0x2E, 0x00},	//DISCHARGE1 (2Dh) TBD
+	{0x2F, 0x00},
+	{0x30, 0x00},
+	{0x31, 0x00},
+	{0x32, 0x00},
+	{0x33, 0x00},
+	{0x34, 0x00},
+	{0x35, 0x00},
+	{0x36, 0x00},
+	{0x37, 0x00},
+	{0x38, 0x00},
+	{0x39, 0x00},
+	{0x3A, 0x00},
+	{0x3B, 0x00},
+	{0x3C, 0x00},
+	{0x3D, 0x00},
+	{0x3E, 0x00},
+	{0x3F, 0x00},
+	{0x40, 0x00},
+	{0x41, 0x05},
+	{0x42, 0x00},
+	{0x43, 0x00},
+	{0x44, 0x00},
+	{0x45, 0x00},
+	{0x46, 0x00},
+	{0x47, 0x00},
+	{0x48, 0x00},
+	{0x49, 0x00},
+	{0x4A, 0x00},
+	{0x4B, 0x00},
+	{0x4C, 0x00},
+	{0x4D, 0x00},
+	{0x4E, 0x00},
+	{0x4F, 0x00},
+	{0x50, 0x00},
+	{0x51, 0x00},
+	{0x52, 0x00},
+	{0x53, 0x00},
+	{0x54, 0x00},
+	{0x55, 0x00},
+	{0x56, 0x00},
+	{0x57, 0x00},
+	{0x58, 0x00},
+	{0x59, 0x00},
+	{0x5A, 0x00},
+	{0x5B, 0x00},
+	{0x5C, 0x00},
+	{0x5D, 0x00},
+	{0x5E, 0x00},
+	{0x5F, 0x00},
+	{0x60, 0x00},
+	{0x61, 0x00},
+	{0x62, 0x00},
+	{0x63, 0x00},
+
+};
+u8 pmic_active=0;
+#define TPS659122_PMIC_ACTIVE 1
+#define TPS659122_PMIC_NOT_ACTIVE 0
+u8 tps65912_PMIC_Register_powerON_sequence[10][3] = {
+/*	{Add, value, delay}	
+	{0x62, 0x0d, 0x00}, //switsh
+	{0x0E, 0x80, 0x0}, //DCDC4
+	{0x05, 0x80, 0x0}, //DCDC1
+	{0x0B, 0x80, 0x0}, //DCDC3
+	{0x11, 0x80, 0x0}, //LDO1
+	{0x1A, 0x80, 0x0},	//LDO4
+	{0x1C, 0x80, 0x0},	//LDO5
+	{0x1E, 0x80, 0x0},	//LDO7
+	{0x20, 0x80, 0x0},	//LDO9
+	{0x21, 0x80, 0x0},	//LDO10*/
+
+};
+
+
+#endif  /* __CSG1K_PMIC_TABLES__ */
+
diff -ruN kernel_orig/nvidia/drivers/media/i2c/Kconfig kernel_ams/nvidia/drivers/media/i2c/Kconfig
--- kernel_orig/nvidia/drivers/media/i2c/Kconfig	2021-07-26 21:08:47.000000000 +0200
+++ kernel_ams/nvidia/drivers/media/i2c/Kconfig	2022-02-03 12:40:17.038841043 +0100
@@ -31,6 +31,15 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called imx219.
 
+config VIDEO_CSG1K
+	tristate "CSG1K evaluation system support"
+	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
+	---help---
+	  This is a Video4Linux2 sensor-level driver for the ams image sensor evaluation system.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called csg1k.
+
 config VIDEO_IMX268
 	tristate "IMX268 camera sensor support"
 	depends on I2C && VIDEO_V4L2 && VIDEO_V4L2_SUBDEV_API
diff -ruN kernel_orig/nvidia/drivers/media/i2c/Makefile kernel_ams/nvidia/drivers/media/i2c/Makefile
--- kernel_orig/nvidia/drivers/media/i2c/Makefile	2021-07-26 21:08:47.000000000 +0200
+++ kernel_ams/nvidia/drivers/media/i2c/Makefile	2022-02-03 12:40:17.039841057 +0100
@@ -7,6 +7,7 @@
 obj-$(CONFIG_VIDEO_IMX185) += imx185_v1.o
 obj-$(CONFIG_VIDEO_IMX477) += imx477.o
 obj-$(CONFIG_VIDEO_IMX219) += imx219.o
+obj-$(CONFIG_VIDEO_CSG1K) += csg1k.o
 obj-$(CONFIG_VIDEO_IMX268) += imx268.o
 obj-$(CONFIG_VIDEO_IMX274) += imx274.o
 obj-$(CONFIG_VIDEO_IMX318) += imx318.o
diff -ruN kernel_orig/nvidia/drivers/media/platform/tegra/camera/camera_common.c kernel_ams/nvidia/drivers/media/platform/tegra/camera/camera_common.c
--- kernel_orig/nvidia/drivers/media/platform/tegra/camera/camera_common.c	2021-07-26 21:08:47.000000000 +0200
+++ kernel_ams/nvidia/drivers/media/platform/tegra/camera/camera_common.c	2022-02-03 12:40:17.040841071 +0100
@@ -57,6 +57,11 @@
 		V4L2_PIX_FMT_SGBRG12
 	},
 	{
+		MEDIA_BUS_FMT_SBGGR12_1X12,
+		V4L2_COLORSPACE_SRGB,
+		V4L2_PIX_FMT_SBGGR12,
+	},
+	{
 		MEDIA_BUS_FMT_SRGGB10_1X10,
 		V4L2_COLORSPACE_SRGB,
 		V4L2_PIX_FMT_SRGGB10,
@@ -81,6 +86,21 @@
 		V4L2_COLORSPACE_SRGB,
 		V4L2_PIX_FMT_SRGGB8,
 	},
+ 	{
+		MEDIA_BUS_FMT_SBGGR8_1X8,
+		V4L2_COLORSPACE_SRGB,
+		V4L2_PIX_FMT_SBGGR8,
+	},
+	{
+		MEDIA_BUS_FMT_SGRBG8_1X8,
+		V4L2_COLORSPACE_SRGB,
+		V4L2_PIX_FMT_SGRBG8,
+	},
+	{
+		MEDIA_BUS_FMT_SGBRG8_1X8,
+		V4L2_COLORSPACE_SRGB,
+		V4L2_PIX_FMT_SGBRG8,
+	},
 	{
 		MEDIA_BUS_FMT_YUYV8_1X16,
 		V4L2_COLORSPACE_SRGB,
diff -ruN kernel_orig/nvidia/drivers/media/platform/tegra/camera/sensor_common.c kernel_ams/nvidia/drivers/media/platform/tegra/camera/sensor_common.c
--- kernel_orig/nvidia/drivers/media/platform/tegra/camera/sensor_common.c	2021-07-26 21:08:47.000000000 +0200
+++ kernel_ams/nvidia/drivers/media/platform/tegra/camera/sensor_common.c	2022-02-03 12:40:17.040841071 +0100
@@ -209,10 +209,18 @@
 		*format = V4L2_PIX_FMT_SBGGR12;
 	else if (strncmp(pixel_t, "bayer_rggb12", size) == 0)
 		*format = V4L2_PIX_FMT_SRGGB12;
-	else if (strncmp(pixel_t, "bayer_gbrg12", size) == 0)
-		*format = V4L2_PIX_FMT_SGBRG12;
 	else if (strncmp(pixel_t, "bayer_grbg12", size) == 0)
 		*format = V4L2_PIX_FMT_SGRBG12;
+	else if (strncmp(pixel_t, "bayer_gbrg12", size) == 0)
+		*format = V4L2_PIX_FMT_SGBRG12;
+	else if (strncmp(pixel_t, "bayer_bggr8", size) == 0)
+		*format = V4L2_PIX_FMT_SBGGR8;
+	else if (strncmp(pixel_t, "bayer_rggb8", size) == 0)
+		*format = V4L2_PIX_FMT_SRGGB8;
+	else if (strncmp(pixel_t, "bayer_grbg8", size) == 0)
+		*format = V4L2_PIX_FMT_SGRBG8;
+	else if (strncmp(pixel_t, "bayer_gbrg8", size) == 0)
+		*format = V4L2_PIX_FMT_SGBRG8;
 	else if (strncmp(pixel_t, "rgb_rgb88824", size) == 0)
 		*format = V4L2_PIX_FMT_RGB24;
 	else if (strncmp(pixel_t, "bayer_wdr_pwl_rggb12", size) == 0)
diff -ruN kernel_orig/nvidia/include/media/csg1k.h kernel_ams/nvidia/include/media/csg1k.h
--- kernel_orig/nvidia/include/media/csg1k.h	1970-01-01 01:00:00.000000000 +0100
+++ kernel_ams/nvidia/include/media/csg1k.h	2022-02-03 12:40:17.041841084 +0100
@@ -0,0 +1,298 @@
+/*
+ * Copyright (c) 2013-2017, NVIDIA CORPORATION.  All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms and conditions of the GNU General Public License,
+ * version 2, as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __CSG1K_H__
+#define __CSG1K_H__
+
+#include <media/nvc.h>
+#include <uapi/media/nvc_image.h>
+
+
+
+
+
+
+/* List of registers for TPS65912 */
+#define TPS65912_I2C_ADDRESS		0x2d
+#define TPS65912_DCDC1_CTRL		0x00
+#define TPS65912_DCDC2_CTRL		0x01
+#define TPS65912_DCDC3_CTRL		0x02
+#define TPS65912_DCDC4_CTRL		0x03
+#define TPS65912_DCDC1_OP		0x04
+#define TPS65912_DCDC1_AVS		0x05
+#define TPS65912_DCDC1_LIMIT	0x06
+#define TPS65912_DCDC2_OP		0x07
+#define TPS65912_DCDC2_AVS		0x08
+#define TPS65912_DCDC2_LIMIT	0x09
+#define TPS65912_DCDC3_OP		0x0A
+#define TPS65912_DCDC3_AVS		0x0B
+#define TPS65912_DCDC3_LIMIT	0x0C
+#define TPS65912_DCDC4_OP		0x0D
+#define TPS65912_DCDC4_AVS		0x0E
+#define TPS65912_DCDC4_LIMIT	0x0F
+#define TPS65912_LDO1_OP		0x10
+#define TPS65912_LDO1_AVS		0x11
+#define TPS65912_LDO1_LIMIT		0x12
+#define TPS65912_LDO2_OP		0x13
+#define TPS65912_LDO2_AVS		0x14
+#define TPS65912_LDO2_LIMIT		0x15
+#define TPS65912_LDO3_OP		0x16
+#define TPS65912_LDO3_AVS		0x17
+#define TPS65912_LDO3_LIMIT		0x18
+#define TPS65912_LDO4_OP		0x19
+#define TPS65912_LDO4_AVS		0x1A
+#define TPS65912_LDO4_LIMIT		0x1B
+#define TPS65912_LDO5			0x1C
+#define TPS65912_LDO6			0x1D
+#define TPS65912_LDO7			0x1E
+#define TPS65912_LDO8			0x1F
+#define TPS65912_LDO9			0x20
+#define TPS65912_LDO10			0x21
+#define TPS65912_THRM			0x22
+#define TPS65912_CLK32OUT		0x23
+#define TPS65912_DEVCTRL		0x24
+#define TPS65912_DEVCTRL2		0x25
+#define TPS65912_I2C_SPI_CFG	0x26
+#define TPS65912_KEEP_ON		0x27
+#define TPS65912_KEEP_ON2		0x28
+#define TPS65912_SET_OFF1		0x29
+#define TPS65912_SET_OFF2		0x2A
+#define TPS65912_DEF_VOLT		0x2B
+#define TPS65912_DEF_VOLT_MAPPING	0x2C
+#define TPS65912_DISCHARGE		0x2D
+#define TPS65912_DISCHARGE2		0x2E
+#define TPS65912_EN1_SET1		0x2F
+#define TPS65912_EN1_SET2		0x30
+#define TPS65912_EN2_SET1		0x31
+#define TPS65912_EN2_SET2		0x32
+#define TPS65912_EN3_SET1		0x33
+#define TPS65912_EN3_SET2		0x34
+#define TPS65912_EN4_SET1		0x35
+#define TPS65912_EN4_SET2		0x36
+#define TPS65912_PGOOD			0x37
+#define TPS65912_PGOOD2			0x38
+#define TPS65912_INT_STS		0x39
+#define TPS65912_INT_MSK		0x3A
+#define TPS65912_INT_STS2		0x3B
+#define TPS65912_INT_MSK2		0x3C
+#define TPS65912_INT_STS3		0x3D
+#define TPS65912_INT_MSK3		0x3E
+#define TPS65912_INT_STS4		0x3F
+#define TPS65912_INT_MSK4		0x40
+#define TPS65912_GPIO1			0x41
+#define TPS65912_GPIO2			0x42
+#define TPS65912_GPIO3			0x43
+#define TPS65912_GPIO4			0x44
+#define TPS65912_GPIO5			0x45
+#define TPS65912_VMON			0x46
+#define TPS65912_LEDA_CTRL1		0x47
+#define TPS65912_LEDA_CTRL2		0x48
+#define TPS65912_LEDA_CTRL3		0x49
+#define TPS65912_LEDA_CTRL4		0x4A
+#define TPS65912_LEDA_CTRL5		0x4B
+#define TPS65912_LEDA_CTRL6		0x4C
+#define TPS65912_LEDA_CTRL7		0x4D
+#define TPS65912_LEDA_CTRL8		0x4E
+#define TPS65912_LEDB_CTRL1		0x4F
+#define TPS65912_LEDB_CTRL2		0x50
+#define TPS65912_LEDB_CTRL3		0x51
+#define TPS65912_LEDB_CTRL4		0x52
+#define TPS65912_LEDB_CTRL5		0x53
+#define TPS65912_LEDB_CTRL6		0x54
+#define TPS65912_LEDB_CTRL7		0x55
+#define TPS65912_LEDB_CTRL8		0x56
+#define TPS65912_LEDC_CTRL1		0x57
+#define TPS65912_LEDC_CTRL2		0x58
+#define TPS65912_LEDC_CTRL3		0x59
+#define TPS65912_LEDC_CTRL4		0x5A
+#define TPS65912_LEDC_CTRL5		0x5B
+#define TPS65912_LEDC_CTRL6		0x5C
+#define TPS65912_LEDC_CTRL7		0x5D
+#define TPS65912_LEDC_CTRL8		0x5E
+#define TPS65912_LED_RAMP_UP_TIME	0x5F
+#define TPS65912_LED_RAMP_DOWN_TIME	0x60
+#define TPS65912_LED_SEQ_EN		0x61
+#define TPS65912_LOADSWITCH		0x62
+#define TPS65912_SPARE			0x63
+#define TPS65912_VERNUM			0x64
+#define TPS6591X_MAX_REGISTER	0x64
+#define TPS6591X_PWR_ON			1
+#define TPS6591X_PWR_OFF		0
+
+
+/* List of registers for CSG1K */
+
+#define CSG1K_PLL_LOCKED		268
+#define CSG1K_CTRL_MODE			139
+
+
+
+
+
+#define CSG1K_IOCTL_SET_MODE               _IOW('o', 1, struct csg1k_mode)
+#define CSG1K_IOCTL_SET_FRAME_LENGTH       _IOW('o', 2, __u32)
+#define CSG1K_IOCTL_SET_COARSE_TIME        _IOW('o', 3, __u32)
+#define CSG1K_IOCTL_SET_GAIN               _IOW('o', 4, __u16)
+#define CSG1K_IOCTL_GET_STATUS             _IOR('o', 5, __u8)
+#define CSG1K_IOCTL_SET_BINNING            _IOW('o', 6, __u8)
+#define CSG1K_IOCTL_TEST_PATTERN           _IOW('o', 7, \
+						 enum csg1k_test_pattern)
+#define CSG1K_IOCTL_SET_GROUP_HOLD         _IOW('o', 8, struct csg1k_ae)
+/* IOCTL to set the operating mode of camera.
+ * This can be either stereo , leftOnly or rightOnly */
+#define CSG1K_IOCTL_SET_CAMERA_MODE        _IOW('o', 10, __u32)
+#define CSG1K_IOCTL_SYNC_SENSORS           _IOW('o', 11, __u32)
+#define CSG1K_IOCTL_GET_FUSEID             _IOR('o', 12, struct nvc_fuseid)
+#define CSG1K_IOCTL_SET_HDR_COARSE_TIME    _IOW('o', 13, struct csg1k_hdr)
+#define CSG1K_IOCTL_READ_OTP_BANK          _IOWR('o', 14, \
+						struct csg1k_otp_bank)
+#define CSG1K_IOCTL_SET_CAL_DATA           _IOW('o', 15, \
+						struct csg1k_cal_data)
+#define CSG1K_IOCTL_GET_EEPROM_DATA        _IOR('o', 20, __u8 *)
+#define CSG1K_IOCTL_SET_EEPROM_DATA        _IOW('o', 21, __u8 *)
+#define CSG1K_IOCTL_GET_CAPS               _IOR('o', 22, struct nvc_imager_cap)
+#define CSG1K_IOCTL_SET_POWER              _IOW('o', 23, __u32)
+
+#define CSG1K_INVALID_COARSE_TIME  -1
+
+#define CSG1K_EEPROM_ADDRESS		0x50
+#define CSG1K_EEPROM_SIZE		1024
+#define CSG1K_EEPROM_STR_SIZE		(CSG1K_EEPROM_SIZE * 2)
+#define CSG1K_EEPROM_BLOCK_SIZE	(1 << 8)
+#define CSG1K_EEPROM_NUM_BLOCKS \
+	(CSG1K_EEPROM_SIZE / CSG1K_EEPROM_BLOCK_SIZE)
+
+#define CSG1K_OTP_LOAD_CTRL_ADDR	0x3D81
+#define CSG1K_OTP_BANK_SELECT_ADDR	0x3D84
+#define CSG1K_OTP_BANK_START_ADDR	0x3D00
+#define CSG1K_OTP_BANK_END_ADDR	0x3D0F
+#define CSG1K_OTP_NUM_BANKS		(32)
+#define CSG1K_OTP_BANK_SIZE \
+	 (CSG1K_OTP_BANK_END_ADDR - CSG1K_OTP_BANK_START_ADDR + 1)
+#define CSG1K_OTP_SIZE \
+	 (CSG1K_OTP_BANK_SIZE * CSG1K_OTP_NUM_BANKS)
+#define CSG1K_OTP_STR_SIZE (CSG1K_OTP_SIZE * 2)
+
+#define CSG1K_FUSE_ID_OTP_START_ADDR	0x3D00
+#define CSG1K_FUSE_ID_OTP_BANK	0
+#define CSG1K_FUSE_ID_SIZE		8
+#define CSG1K_FUSE_ID_STR_SIZE	(CSG1K_FUSE_ID_SIZE * 2)
+
+#define CSG1K_FRAME_LENGTH_ADDR_MSB		0x380E
+#define CSG1K_FRAME_LENGTH_ADDR_LSB		0x380F
+#define CSG1K_COARSE_TIME_ADDR_1		0x3500
+#define CSG1K_COARSE_TIME_ADDR_2		0x3501
+#define CSG1K_COARSE_TIME_ADDR_3		0x3502
+#define CSG1K_COARSE_TIME_SHORT_ADDR_1	0x3506
+#define CSG1K_COARSE_TIME_SHORT_ADDR_2	0x3507
+#define CSG1K_COARSE_TIME_SHORT_ADDR_3	0x3508
+#define CSG1K_GAIN_ADDR_MSB			0x350A
+#define CSG1K_GAIN_ADDR_LSB			0x350B
+#define CSG1K_GROUP_HOLD_ADDR			0x3208
+#define CSG1K_TIMING_REG20			0x3820
+#define VERTICAL_FLIP				((0x1 << 1) | (0x1 << 6))
+#define CSG1K_TIMING_REG21			0x3821
+#define HORIZONTAL_MIRROR_MASK			(0x3 << 1)
+
+struct csg1k_mode {
+	int res_x;
+	int res_y;
+	int fps;
+	__u32 frame_length;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u16 gain;
+	__u8 hdr_en;
+};
+
+struct csg1k_ae {
+	__u32 frame_length;
+	__u8  frame_length_enable;
+	__u32 coarse_time;
+	__u32 coarse_time_short;
+	__u8  coarse_time_enable;
+	__s32 gain;
+	__u8  gain_enable;
+};
+
+struct csg1k_fuseid {
+	__u32 size;
+	__u8  id[16];
+};
+
+struct csg1k_hdr {
+	__u32 coarse_time_long;
+	__u32 coarse_time_short;
+};
+
+struct csg1k_otp_bank {
+	__u32 id;
+	__u8  buf[16];
+};
+
+struct csg1k_cal_data {
+	int loaded;
+	int rg_ratio;
+	int bg_ratio;
+	int rg_ratio_typical;
+	int bg_ratio_typical;
+	__u8 lenc[62];
+};
+
+/* See notes in the nvc.h file on the GPIO usage */
+enum csg1k_gpio_type {
+	CSG1K_GPIO_TYPE_PWRDN = 0,
+	CSG1K_GPIO_TYPE_RESET,
+};
+
+struct csg1k_eeprom_data {
+	struct i2c_client *i2c_client;
+	struct i2c_adapter *adap;
+	struct i2c_board_info brd;
+	struct regmap *regmap;
+};
+
+struct csg1k_power_rail {
+	struct regulator *dvdd;
+	struct regulator *avdd;
+	struct regulator *dovdd;
+};
+
+struct csg1k_regulators {
+	const char *avdd;
+	const char *dvdd;
+	const char *dovdd;
+};
+
+struct csg1k_platform_data {
+	unsigned cfg;
+	unsigned num;
+	const char *dev_name;
+	unsigned gpio_count; /* see nvc.h GPIO notes */
+	struct nvc_gpio_pdata *gpio; /* see nvc.h GPIO notes */
+	struct nvc_imager_static_nvc *static_info;
+	bool use_vcm_vdd;
+	int (*probe_clock)(unsigned long);
+	int (*power_on)(struct csg1k_power_rail *);
+	int (*power_off)(struct csg1k_power_rail *);
+	const char *mclk_name;
+	struct nvc_imager_cap *cap;
+	struct csg1k_regulators regulators;
+	bool has_eeprom;
+	bool use_cam_gpio;
+};
+
+#endif  /* __CSG1K_H__ */
diff -ruN kernel_orig/nvidia/include/media/tegra-v4l2-camera.h kernel_ams/nvidia/include/media/tegra-v4l2-camera.h
--- kernel_orig/nvidia/include/media/tegra-v4l2-camera.h	2021-07-26 21:08:48.000000000 +0200
+++ kernel_ams/nvidia/include/media/tegra-v4l2-camera.h	2022-02-03 12:40:17.041841084 +0100
@@ -22,7 +22,16 @@
 #include <linux/v4l2-controls.h>
 
 #define TEGRA_CAMERA_CID_BASE	(V4L2_CTRL_CLASS_CAMERA | 0x2000)
-
+/*test v4l2 control*/
+#define TEGRA_CAMERA_BRIGHTNESS_TEST		(V4L2_CID_BRIGHTNESS)
+#define TEGRA_CAMERA_CONTRAST_TEST		(V4L2_CID_CONTRAST)
+#define TEGRA_CAMERA_GAMMA_TEST			(V4L2_CID_GAMMA)
+#define TEGRA_CAMERA_USER_TEST			(V4L2_CID_USER_BASE + 0x1100)
+#define TEGRA_CAMERA_USER_TEST2			(V4L2_CID_USER_BASE + 0x1102)
+#define TEGRA_CAMERA_USER_TEST3			(V4L2_CID_USER_BASE + 0x1104)
+#define TEGRA_CAMERA_USER_TEST4			(V4L2_CID_USER_BASE + 0x1106)
+#define TEGRA_CAMERA_USER_TEST5			(V4L2_CID_USER_BASE + 0x1108)
+#define TEGRA_CAMERA_USER_TEST6			(V4L2_CID_USER_BASE + 0x110A)
 #define TEGRA_CAMERA_CID_FRAME_LENGTH		(TEGRA_CAMERA_CID_BASE+0)
 #define TEGRA_CAMERA_CID_COARSE_TIME		(TEGRA_CAMERA_CID_BASE+1)
 #define TEGRA_CAMERA_CID_COARSE_TIME_SHORT	(TEGRA_CAMERA_CID_BASE+2)
